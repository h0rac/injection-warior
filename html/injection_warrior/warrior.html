<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>injection_warrior.warrior API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>injection_warrior.warrior</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Author h0rac
from injection_warrior import common
import hashlib
import requests
import sys
import itertools
from bs4 import BeautifulSoup
import aiohttp
from aiohttp import FormData
import sys
import asyncio
import time
import hashlib
import requests
import zipfile
import json
from bs4 import BeautifulSoup
from termcolor import colored
from urllib.parse import urlparse
from prettytable import PrettyTable
import io
import zipfile
import gzip


class Injector(common.Common):
    &#34;&#34;&#34;Main class of the framework
    &#34;&#34;&#34;

    def __init__(self, proxy=None, debug=False, allow_redirects=True):
        &#34;&#34;&#34;AI is creating summary for __init__

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        self.allow_redirects = allow_redirects
        self.resp_json = False
        self.req_json = False
        self.json_resp = None
        self.html = False
        self.elapsed = None
        self.params = None
        self.req_counter = 0
        self.counter = 0
        self.header_param = {}
        self.body_param = {}
        self.cookie = {}
        self.url_param = {}
        self.resp_body = True
        self.input_payload = []
        self.excluded = []


    def _params_converted(self, payloads=[], params={}):
        if isinstance(params, aiohttp.FormData):
            return [params]
        dict_params = {}
        try:
            if len(payloads) == 0:
                payloads = [&#34;&#34;]
            params_list = []
            for p in payloads:
                data = json.dumps(params)
                data = data.replace(&#34;%$%&#34;, str(p))
                dict_params = json.loads(data)
                params_list.append(dict_params)
            if self.debug:
                print(
                    colored(&#34;[*] Params converted: {}&#34;.format(params_list), &#34;white&#34;))
            return params_list
        except ValueError as e:
            print(colored(&#34;[-] Error _params_converted: {}&#34;.format(e), &#34;red&#34;))
            sys.exit(0)

   

    async def _fetch(self, http_method=&#34;get&#34;, session=None, url=None, html=False, injection_point=&#34;url&#34;, body_param={}, req_json=False, resp_json=False, cookie=None, url_param={}, header_param={}):
        # START HANDLERS FOR HEADER
        self.resp_json = resp_json
        self.html = html
        self.req_json = req_json
    
                
        self.req_counter += 1
        if injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, data=body_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
          
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;get&#34; and not req_json:
            async with session.get(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
  
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
            
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;put&#34; and not req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;patch&#34; and not req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
       
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;delete&#34; and not req_json:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;head&#34; and not req_json:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;options&#34; and not req_json:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR HEADER
        # START HANDLERS FOR URL
        elif injection_point == &#34;url&#34; and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;post&#34; and req_json:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;post&#34; and not req_json:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;put&#34; and req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;put&#34; and not req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;patch&#34; and req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;patch&#34; and not req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR URL

        # START HANDLERS FOR COOKIE

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and http_method == &#34;get&#34; and not req_json:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR COOKIE

        # START HANDLERS FOR BODY

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
               
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        # END HANDLERS FOR BODY

    async def _display(self, response=None, body_param={}, html=False, resp_json=None, cookie_param={}, url_param={}, header_param={}):
        multiplier = 60 
        resp = response
        parsed_url = urlparse(str(resp.url))
        question_mark = &#34;?&#34;
        
        if len(body_param.keys()) &gt; 0:
            self.input_payload = body_param    
        elif len(cookie_param.keys()) &gt; 0:
            self.input_payload = cookie_param    
        elif len(url_param.keys()) &gt; 0:
             self.input_payload = url_param    
        elif len(header_param.keys()) &gt; 0:
            self.input_payload = header_param

        print(&#34;\r\n&#34;)
        print(colored(&#34;-&#34;*multiplier+&#34;REQUEST {} HEADERS&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
        print(&#34;\r\n&#34;)
        question_mark = &#34;?&#34;
        print(colored(&#34;[+] {} {}{}{} HTTP/1.1&#34;.format(resp.method.upper(), parsed_url.path if parsed_url.path != &#39;&#39; else &#34;/&#34; , question_mark if resp.url.query_string else &#39;&#39;,
                                                        resp.url.query_string if resp.url.query_string != None else None), &#34;yellow&#34;))
        if &#39;Host&#39; not in resp.request_info.headers:
            print(
                colored(&#34;[+] Host: {}&#34;.format(parsed_url.netloc), &#34;yellow&#34;))
        for k, v in resp.request_info.headers.items():
            print(colored(&#34;[+] {}: {}&#34;.format(k, v), &#34;yellow&#34;))
           
        if resp.method != &#34;GET&#34;:
            if self.req_json:
                print(&#34;\r\n&#34;)
                print(colored(&#34;-&#34;*multiplier +
                            &#34;REQUEST {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                print(&#34;\r\n&#34;)
                print(json.dumps(body_param, indent=2))
            else:
                print(&#34;\r\n&#34;)
                print(colored(&#34;-&#34;*multiplier+&#34;REQUEST BODY&#34;+&#34;-&#34;*multiplier, &#34;blue&#34;))
                print(&#34;\r\n&#34;)
                if isinstance(body_param, aiohttp.FormData):
                    for param in body_param._fields:
                        for p in param:
                            print(p)
                else:
                    print(body_param) 
    
        print(&#34;\r\n&#34;)
        print(colored(&#34;-&#34;*multiplier +
                        &#34;RESPONSE {} HEADERS&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
        print(&#34;\r\n&#34;)
        print(colored(&#34;[+] HTTP/1.1 {}&#34;.format(resp.status), &#34;cyan&#34;))
        for k, v in resp.headers.items():
            print(colored(&#34;[+] {}: {}&#34;.format(k, v), &#34;cyan&#34;))
            
        if html:
            resp = await response.text()
            self.json_resp = None
            self.soup = BeautifulSoup(resp, &#34;html.parser&#34;)
            if self.resp_body:
                if self.html:
                    checked = self._check_reflected_params(input_payload=self.input_payload, response = self.soup.prettify())
                    print(&#34;\r\n&#34;)
                    print(colored(&#34;-&#34;*multiplier +
                                    &#34;RESPONSE {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                    print(&#34;\r\n&#34;)
                    print(checked, &#39;white&#39;)
            return {&#34;json_resp&#34;: self.json_resp, &#34;raw_response&#34;: response, &#34;soup&#34;:self.soup, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        elif not html and resp_json:
            self.json_resp = await response.json(content_type=None)
            if self.resp_body:
                if self.resp_json:
                    string_response = json.dumps(self.json_resp, indent=2)
                    checked = self._check_reflected_params(input_payload=self.input_payload, response=string_response)
                    print(&#34;\r\n&#34;)
                    print(colored(&#34;-&#34;*multiplier +
                                    &#34;RESPONSE {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                    print(&#34;\r\n&#34;)
                    print(checked)
            return {&#34;json_resp&#34;: self.json_resp, &#34;raw_response&#34;: response, &#34;soup&#34;: None, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        return {&#34;json_resp&#34;: None, &#34;raw_response&#34;: response, &#34;soup&#34;: None, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        

    def _check_reflected_params(self, input_payload={}, response=&#34;&#34;):
        colored_resp = response
        for k,v in input_payload.items():
            if isinstance(v, dict):
                colored_resp = self._check_reflected_params(v, colored_resp)
            elif isinstance(v, list):
                for item in v:
                    colored_resp = self._check_reflected_params(item, colored_resp)
            elif v in response and k not in self.excluded:
                colored_resp = colored_resp.replace(v, colored(v, &#34;red&#34;))
        return colored_resp
                

    async def _on_request_start(self, session, trace_config_ctx, params):
        print(colored(&#34;[+] Starting request...&#34;, &#34;magenta&#34;), end=&#39;\r&#39;)
        start_time = time.time()
        trace_config_ctx.start = start_time

    async def _on_request_end(self, session, trace_config_ctx, params):
        self.counter +=1
        end_time = time.time()
        self.elapsed = end_time - trace_config_ctx.start
        
    async def _fetch_all(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params=[], req_json=False, resp_json=False, cookie_params=[], url_params=[], header_params=[]):

        trace_config = aiohttp.TraceConfig()
        trace_config.on_request_start.append(self._on_request_start)
        trace_config.on_request_end.append(self._on_request_end)

        if injection_point == &#34;url&#34; and len(urls) &gt; 1:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(urls)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[i],
                            html=html,
                            injection_point=injection_point,
                            body_param=body_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                            url_param=url_params[i],
                            header_param=header_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;url&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(url_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            injection_point=injection_point,
                            body_param=body_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                            url_param=url_params[i],
                            header_param=header_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;body&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(body_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params[i],
                            header_param=header_params,
                            injection_point=injection_point,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses
        elif injection_point == &#34;cookie&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(cookie_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params,
                            injection_point=injection_point,
                            header_param=header_params,
                            url_param=url_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params[i],
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;header&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(header_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params,
                            injection_point=injection_point,
                            header_param=header_params[i],
                            url_param=url_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params=[], url_params=[], header_params=[], resp_body=None):
        &#34;&#34;&#34;AI is creating summary for _run

        Args:
            http_method (str, optional): [description]. Defaults to &#34;get&#34;.
            url (str, optional): [description]. Defaults to &#34;&#34;.
            html (bool, optional): [description]. Defaults to False.
            injection_point (str, optional): [description]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [description]. Defaults to {}.
            req_json (bool, optional): [description]. Defaults to False.
            resp_json (bool, optional): [description]. Defaults to False.
            cookie_params (list, optional): [description]. Defaults to [].
            url_params (list, optional): [description]. Defaults to [].
            header_params (list, optional): [description]. Defaults to [].

        Returns:
            list]: async HTTP responses list
        &#34;&#34;&#34;
        self.resp_body = resp_body
        responses_list = []
        responses = asyncio.run(self._fetch_all(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                                body_params=body_params, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params, url_params=url_params, header_params=header_params))
        # print(colored(
        #     &#34;[+] Total executed requests: {}.&#34;.format(self.req_counter), &#34;magenta&#34;))
        print(&#34;\r\n&#34;)
        print(colored(
            &#34;[+] Total time elapsed: {} seconds&#34;.format(self.elapsed), &#34;magenta&#34;))
        return responses

    def inject_payload(self, url=&#34;&#34;, payloads=[], http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  body_params={}, 
                       req_json=False, resp_json=False, html=False, cookie_params={}, url_params={}, 
                       header_params={}, resp_body=True, noise_params=[], **kwargs):
        &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
           When payloads are used, header|body|cookie|url dictionary should have value as %$%
           example: url_params = {&#34;productId&#34;: %$%}

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        if injection_point == &#34;body&#34; and http_method == &#34;get&#34;:
            print(colored(
                &#34;[-] Unsupported combination for {} and {}&#34;.format(injection_point, http_method), &#34;red&#34;))
            sys.exit(0)
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] Injection &#39;Warrior&#39; selected parameters: 
            PAYLOADS: {}
            HTTP METHOD: {}
            URL: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            HEADER PARAMS: {}
            QUOTE TYPE: {}
            REQ JSON: {}
            RESP JSON: {}
            RESP_BODY: {}
            NOISE PARAMS: {}
            KWARGS:{}
            &#39;&#39;&#39;.format(payloads, http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, resp_body, noise_params, kwargs), &#34;yellow&#34;))
        values = []
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        http_method = http_method.lower()
        self.http_method = http_method
        self.excluded = noise_params
        
        if len(payloads) == 0 and isinstance(url, list):
            urls = url
        else:
            urls = self._url_path_parse(url, payloads)
            if not len(urls) &gt; 0:
                urls = [url]
        
      
        if injection_point == &#34;header&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            header_params_list = self._params_converted(
                payloads=values, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, header_params=header_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;url&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            url_params_list = self._params_converted(
                payloads=values, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params, resp_body=resp_body)

        elif injection_point == &#34;body&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            body_params_list = self._params_converted(
                payloads=values, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params_list, injection_point=injection_point, cookie_params=cookie_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;cookie&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            cookie_params_list = self._params_converted(
                payloads=values, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, injection_point=injection_point, cookie_params=cookie_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)       

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        urls = []
        if &#34;%$%&#34; in url:
            for p in payloads:
                temp = url.replace(&#34;%$%&#34;, str(p))
                urls.append(temp)
        return urls</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="injection_warrior.warrior.Injector"><code class="flex name class">
<span>class <span class="ident">Injector</span></span>
<span>(</span><span>proxy=None, debug=False, allow_redirects=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the framework</p>
<p>AI is creating summary for <strong>init</strong></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proxy</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Injector(common.Common):
    &#34;&#34;&#34;Main class of the framework
    &#34;&#34;&#34;

    def __init__(self, proxy=None, debug=False, allow_redirects=True):
        &#34;&#34;&#34;AI is creating summary for __init__

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        self.allow_redirects = allow_redirects
        self.resp_json = False
        self.req_json = False
        self.json_resp = None
        self.html = False
        self.elapsed = None
        self.params = None
        self.req_counter = 0
        self.counter = 0
        self.header_param = {}
        self.body_param = {}
        self.cookie = {}
        self.url_param = {}
        self.resp_body = True
        self.input_payload = []
        self.excluded = []


    def _params_converted(self, payloads=[], params={}):
        if isinstance(params, aiohttp.FormData):
            return [params]
        dict_params = {}
        try:
            if len(payloads) == 0:
                payloads = [&#34;&#34;]
            params_list = []
            for p in payloads:
                data = json.dumps(params)
                data = data.replace(&#34;%$%&#34;, str(p))
                dict_params = json.loads(data)
                params_list.append(dict_params)
            if self.debug:
                print(
                    colored(&#34;[*] Params converted: {}&#34;.format(params_list), &#34;white&#34;))
            return params_list
        except ValueError as e:
            print(colored(&#34;[-] Error _params_converted: {}&#34;.format(e), &#34;red&#34;))
            sys.exit(0)

   

    async def _fetch(self, http_method=&#34;get&#34;, session=None, url=None, html=False, injection_point=&#34;url&#34;, body_param={}, req_json=False, resp_json=False, cookie=None, url_param={}, header_param={}):
        # START HANDLERS FOR HEADER
        self.resp_json = resp_json
        self.html = html
        self.req_json = req_json
    
                
        self.req_counter += 1
        if injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, data=body_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
          
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;get&#34; and not req_json:
            async with session.get(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
  
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
            
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;put&#34; and not req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;patch&#34; and not req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
       
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;delete&#34; and not req_json:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;head&#34; and not req_json:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;header&#34; and len(header_param.keys()) &gt; 0 and http_method == &#34;options&#34; and not req_json:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR HEADER
        # START HANDLERS FOR URL
        elif injection_point == &#34;url&#34; and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;post&#34; and req_json:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;post&#34; and not req_json:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;put&#34; and req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;put&#34; and not req_json:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;patch&#34; and req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;patch&#34; and not req_json:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;url&#34; and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR URL

        # START HANDLERS FOR COOKIE

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;get&#34;:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, json=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, cookies=cookie, data=body_param, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and not req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;cookie&#34; and len(cookie.keys()) &gt; 0 and http_method == &#34;get&#34; and not req_json:
            async with session.get(url, proxy=self.proxy, cookies=cookie, params=url_param, headers=header_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        # END HANDLERS FOR COOKIE

        # START HANDLERS FOR BODY

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;post&#34;:
            async with session.post(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
               
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;put&#34;:
            async with session.put(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, data=body_param, cookies=cookie, headers=header_param, params=url_param,allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;patch&#34;:
            async with session.patch(url, proxy=self.proxy, json=body_param, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;head&#34;:
            async with session.head(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;options&#34;:
            async with session.options(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and not req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)

        elif injection_point == &#34;body&#34; and req_json and http_method == &#34;delete&#34;:
            async with session.delete(url, proxy=self.proxy, cookies=cookie, headers=header_param, params=url_param, allow_redirects=self.allow_redirects) as response:
                return await self._display(response=response, body_param=body_param, html=html, resp_json=resp_json, cookie_param=cookie, url_param=url_param, header_param=header_param)
        
        # END HANDLERS FOR BODY

    async def _display(self, response=None, body_param={}, html=False, resp_json=None, cookie_param={}, url_param={}, header_param={}):
        multiplier = 60 
        resp = response
        parsed_url = urlparse(str(resp.url))
        question_mark = &#34;?&#34;
        
        if len(body_param.keys()) &gt; 0:
            self.input_payload = body_param    
        elif len(cookie_param.keys()) &gt; 0:
            self.input_payload = cookie_param    
        elif len(url_param.keys()) &gt; 0:
             self.input_payload = url_param    
        elif len(header_param.keys()) &gt; 0:
            self.input_payload = header_param

        print(&#34;\r\n&#34;)
        print(colored(&#34;-&#34;*multiplier+&#34;REQUEST {} HEADERS&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
        print(&#34;\r\n&#34;)
        question_mark = &#34;?&#34;
        print(colored(&#34;[+] {} {}{}{} HTTP/1.1&#34;.format(resp.method.upper(), parsed_url.path if parsed_url.path != &#39;&#39; else &#34;/&#34; , question_mark if resp.url.query_string else &#39;&#39;,
                                                        resp.url.query_string if resp.url.query_string != None else None), &#34;yellow&#34;))
        if &#39;Host&#39; not in resp.request_info.headers:
            print(
                colored(&#34;[+] Host: {}&#34;.format(parsed_url.netloc), &#34;yellow&#34;))
        for k, v in resp.request_info.headers.items():
            print(colored(&#34;[+] {}: {}&#34;.format(k, v), &#34;yellow&#34;))
           
        if resp.method != &#34;GET&#34;:
            if self.req_json:
                print(&#34;\r\n&#34;)
                print(colored(&#34;-&#34;*multiplier +
                            &#34;REQUEST {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                print(&#34;\r\n&#34;)
                print(json.dumps(body_param, indent=2))
            else:
                print(&#34;\r\n&#34;)
                print(colored(&#34;-&#34;*multiplier+&#34;REQUEST BODY&#34;+&#34;-&#34;*multiplier, &#34;blue&#34;))
                print(&#34;\r\n&#34;)
                if isinstance(body_param, aiohttp.FormData):
                    for param in body_param._fields:
                        for p in param:
                            print(p)
                else:
                    print(body_param) 
    
        print(&#34;\r\n&#34;)
        print(colored(&#34;-&#34;*multiplier +
                        &#34;RESPONSE {} HEADERS&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
        print(&#34;\r\n&#34;)
        print(colored(&#34;[+] HTTP/1.1 {}&#34;.format(resp.status), &#34;cyan&#34;))
        for k, v in resp.headers.items():
            print(colored(&#34;[+] {}: {}&#34;.format(k, v), &#34;cyan&#34;))
            
        if html:
            resp = await response.text()
            self.json_resp = None
            self.soup = BeautifulSoup(resp, &#34;html.parser&#34;)
            if self.resp_body:
                if self.html:
                    checked = self._check_reflected_params(input_payload=self.input_payload, response = self.soup.prettify())
                    print(&#34;\r\n&#34;)
                    print(colored(&#34;-&#34;*multiplier +
                                    &#34;RESPONSE {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                    print(&#34;\r\n&#34;)
                    print(checked, &#39;white&#39;)
            return {&#34;json_resp&#34;: self.json_resp, &#34;raw_response&#34;: response, &#34;soup&#34;:self.soup, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        elif not html and resp_json:
            self.json_resp = await response.json(content_type=None)
            if self.resp_body:
                if self.resp_json:
                    string_response = json.dumps(self.json_resp, indent=2)
                    checked = self._check_reflected_params(input_payload=self.input_payload, response=string_response)
                    print(&#34;\r\n&#34;)
                    print(colored(&#34;-&#34;*multiplier +
                                    &#34;RESPONSE {} BODY&#34;.format(self.counter)+&#34;-&#34;*multiplier, &#34;blue&#34;))
                    print(&#34;\r\n&#34;)
                    print(checked)
            return {&#34;json_resp&#34;: self.json_resp, &#34;raw_response&#34;: response, &#34;soup&#34;: None, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        return {&#34;json_resp&#34;: None, &#34;raw_response&#34;: response, &#34;soup&#34;: None, &#34;cookie&#34;: cookie_param, &#34;url_param&#34;: url_param, &#34;header_param&#34;: header_param, &#34;body_param&#34;: body_param, &#34;elapsed&#34;: self.elapsed}
        

    def _check_reflected_params(self, input_payload={}, response=&#34;&#34;):
        colored_resp = response
        for k,v in input_payload.items():
            if isinstance(v, dict):
                colored_resp = self._check_reflected_params(v, colored_resp)
            elif isinstance(v, list):
                for item in v:
                    colored_resp = self._check_reflected_params(item, colored_resp)
            elif v in response and k not in self.excluded:
                colored_resp = colored_resp.replace(v, colored(v, &#34;red&#34;))
        return colored_resp
                

    async def _on_request_start(self, session, trace_config_ctx, params):
        print(colored(&#34;[+] Starting request...&#34;, &#34;magenta&#34;), end=&#39;\r&#39;)
        start_time = time.time()
        trace_config_ctx.start = start_time

    async def _on_request_end(self, session, trace_config_ctx, params):
        self.counter +=1
        end_time = time.time()
        self.elapsed = end_time - trace_config_ctx.start
        
    async def _fetch_all(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params=[], req_json=False, resp_json=False, cookie_params=[], url_params=[], header_params=[]):

        trace_config = aiohttp.TraceConfig()
        trace_config.on_request_start.append(self._on_request_start)
        trace_config.on_request_end.append(self._on_request_end)

        if injection_point == &#34;url&#34; and len(urls) &gt; 1:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(urls)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[i],
                            html=html,
                            injection_point=injection_point,
                            body_param=body_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                            url_param=url_params[i],
                            header_param=header_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;url&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(url_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            injection_point=injection_point,
                            body_param=body_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                            url_param=url_params[i],
                            header_param=header_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;body&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(body_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params[i],
                            header_param=header_params,
                            injection_point=injection_point,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses
        elif injection_point == &#34;cookie&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(cookie_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params,
                            injection_point=injection_point,
                            header_param=header_params,
                            url_param=url_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params[i],
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

        elif injection_point == &#34;header&#34;:
            async with aiohttp.ClientSession(trace_configs=[trace_config], connector=aiohttp.TCPConnector(ssl=False)) as session:
                tasks = []
                for i in range(0, len(header_params)):
                    tasks.append(
                        self._fetch(
                            http_method=http_method,
                            session=session,
                            url=urls[0],
                            html=html,
                            body_param=body_params,
                            injection_point=injection_point,
                            header_param=header_params[i],
                            url_param=url_params,
                            req_json=req_json,
                            resp_json=resp_json,
                            cookie=cookie_params,
                        )
                    )
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                return responses

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params=[], url_params=[], header_params=[], resp_body=None):
        &#34;&#34;&#34;AI is creating summary for _run

        Args:
            http_method (str, optional): [description]. Defaults to &#34;get&#34;.
            url (str, optional): [description]. Defaults to &#34;&#34;.
            html (bool, optional): [description]. Defaults to False.
            injection_point (str, optional): [description]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [description]. Defaults to {}.
            req_json (bool, optional): [description]. Defaults to False.
            resp_json (bool, optional): [description]. Defaults to False.
            cookie_params (list, optional): [description]. Defaults to [].
            url_params (list, optional): [description]. Defaults to [].
            header_params (list, optional): [description]. Defaults to [].

        Returns:
            list]: async HTTP responses list
        &#34;&#34;&#34;
        self.resp_body = resp_body
        responses_list = []
        responses = asyncio.run(self._fetch_all(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                                body_params=body_params, req_json=req_json, resp_json=resp_json, cookie_params=cookie_params, url_params=url_params, header_params=header_params))
        # print(colored(
        #     &#34;[+] Total executed requests: {}.&#34;.format(self.req_counter), &#34;magenta&#34;))
        print(&#34;\r\n&#34;)
        print(colored(
            &#34;[+] Total time elapsed: {} seconds&#34;.format(self.elapsed), &#34;magenta&#34;))
        return responses

    def inject_payload(self, url=&#34;&#34;, payloads=[], http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  body_params={}, 
                       req_json=False, resp_json=False, html=False, cookie_params={}, url_params={}, 
                       header_params={}, resp_body=True, noise_params=[], **kwargs):
        &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
           When payloads are used, header|body|cookie|url dictionary should have value as %$%
           example: url_params = {&#34;productId&#34;: %$%}

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        if injection_point == &#34;body&#34; and http_method == &#34;get&#34;:
            print(colored(
                &#34;[-] Unsupported combination for {} and {}&#34;.format(injection_point, http_method), &#34;red&#34;))
            sys.exit(0)
        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] Injection &#39;Warrior&#39; selected parameters: 
            PAYLOADS: {}
            HTTP METHOD: {}
            URL: {}
            RETURN HTML: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            HEADER PARAMS: {}
            QUOTE TYPE: {}
            REQ JSON: {}
            RESP JSON: {}
            RESP_BODY: {}
            NOISE PARAMS: {}
            KWARGS:{}
            &#39;&#39;&#39;.format(payloads, http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, resp_body, noise_params, kwargs), &#34;yellow&#34;))
        values = []
        self.resp_json = resp_json
        self.req_json = req_json
        self.html = html
        http_method = http_method.lower()
        self.http_method = http_method
        self.excluded = noise_params
        
        if len(payloads) == 0 and isinstance(url, list):
            urls = url
        else:
            urls = self._url_path_parse(url, payloads)
            if not len(urls) &gt; 0:
                urls = [url]
        
      
        if injection_point == &#34;header&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            header_params_list = self._params_converted(
                payloads=values, params=header_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, header_params=header_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;url&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            url_params_list = self._params_converted(
                payloads=values, params=url_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params, resp_body=resp_body)

        elif injection_point == &#34;body&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            body_params_list = self._params_converted(
                payloads=values, params=body_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params_list, injection_point=injection_point, cookie_params=cookie_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;cookie&#34;:
            values = self._parse_template(payloads=payloads, **kwargs)
            cookie_params_list = self._params_converted(
                payloads=values, params=cookie_params)
            return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, injection_point=injection_point, cookie_params=cookie_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)       

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        urls = []
        if &#34;%$%&#34; in url:
            for p in payloads:
                temp = url.replace(&#34;%$%&#34;, str(p))
                urls.append(temp)
        return urls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="injection_warrior.common.Common" href="common.html#injection_warrior.common.Common">Common</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="injection_warrior.sqli_blind.SQLiBlind" href="sqli_blind.html#injection_warrior.sqli_blind.SQLiBlind">SQLiBlind</a></li>
<li><a title="injection_warrior.sqli_union.SQLiUnion" href="sqli_union.html#injection_warrior.sqli_union.SQLiUnion">SQLiUnion</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="injection_warrior.warrior.Injector.inject_payload"><code class="name flex">
<span>def <span class="ident">inject_payload</span></span>(<span>self, url='', payloads=[], http_method='get', injection_point='url', body_params={}, req_json=False, resp_json=False, html=False, cookie_params={}, url_params={}, header_params={}, resp_body=True, noise_params=[], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>method allows to inject payloads to HTTP request/s
When payloads are used, header|body|cookie|url dictionary should have value as %$%
example: url_params = {"productId": %$%}</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>[URL for endpoint]. Defaults to "".</dd>
<dt><strong><code>payloads</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[list of payloads for which requests will be generated]. Defaults to [].</dd>
<dt><strong><code>http_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to "get".</dd>
<dt><strong><code>injection_point</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[Place where payloads should be injected]. Defaults to "url".</dd>
<dt><strong><code>body_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>req_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if request should be send as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>resp_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>html</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as HTML]. Defaults to False.</dd>
<dt><strong><code>cookie_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>url_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>header_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>resp_body</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response body should be printed on output console]. Defaults to True</dd>
</dl>
<p>kwargs(dict, optional) [quote: "'", delimiter: '+', comment: '&ndash;', comma: ",", oracle: False, nulls: 1, table_name:
"", column_name_1: "", column_name_2: "", sleep: 5]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>Dictionary as key value pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_payload(self, url=&#34;&#34;, payloads=[], http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  body_params={}, 
                   req_json=False, resp_json=False, html=False, cookie_params={}, url_params={}, 
                   header_params={}, resp_body=True, noise_params=[], **kwargs):
    &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
       When payloads are used, header|body|cookie|url dictionary should have value as %$%
       example: url_params = {&#34;productId&#34;: %$%}

    Args:
        url (str): [URL for endpoint]. Defaults to &#34;&#34;.
        payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
        http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
        injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
        body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
        resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
        html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
        cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True
        kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

    Returns:
        [dict]: Dictionary as key value pair
    &#34;&#34;&#34;
    if injection_point == &#34;body&#34; and http_method == &#34;get&#34;:
        print(colored(
            &#34;[-] Unsupported combination for {} and {}&#34;.format(injection_point, http_method), &#34;red&#34;))
        sys.exit(0)
    if self.debug:
        print(colored(
            &#39;&#39;&#39;[+] Injection &#39;Warrior&#39; selected parameters: 
        PAYLOADS: {}
        HTTP METHOD: {}
        URL: {}
        RETURN HTML: {}
        INJECTION POINT: {}
        BODY PARAMS: {}
        COOKIE PARAMS: {}
        URL PARAMS: {}
        HEADER PARAMS: {}
        QUOTE TYPE: {}
        REQ JSON: {}
        RESP JSON: {}
        RESP_BODY: {}
        NOISE PARAMS: {}
        KWARGS:{}
        &#39;&#39;&#39;.format(payloads, http_method, url, html, injection_point, body_params, cookie_params, url_params, header_params, req_json, resp_json, resp_body, noise_params, kwargs), &#34;yellow&#34;))
    values = []
    self.resp_json = resp_json
    self.req_json = req_json
    self.html = html
    http_method = http_method.lower()
    self.http_method = http_method
    self.excluded = noise_params
    
    if len(payloads) == 0 and isinstance(url, list):
        urls = url
    else:
        urls = self._url_path_parse(url, payloads)
        if not len(urls) &gt; 0:
            urls = [url]
    
  
    if injection_point == &#34;header&#34;:
        values = self._parse_template(payloads=payloads, **kwargs)
        header_params_list = self._params_converted(
            payloads=values, params=header_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, header_params=header_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

    elif injection_point == &#34;url&#34;:
        values = self._parse_template(payloads=payloads, **kwargs)
        url_params_list = self._params_converted(
            payloads=values, params=url_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params_list, injection_point=injection_point, cookie_params=cookie_params, req_json=req_json, resp_json=resp_json, header_params=header_params, resp_body=resp_body)

    elif injection_point == &#34;body&#34;:
        values = self._parse_template(payloads=payloads, **kwargs)
        body_params_list = self._params_converted(
            payloads=values, params=body_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params_list, injection_point=injection_point, cookie_params=cookie_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

    elif injection_point == &#34;cookie&#34;:
        values = self._parse_template(payloads=payloads, **kwargs)
        cookie_params_list = self._params_converted(
            payloads=values, params=cookie_params)
        return self._run(http_method=http_method, urls=urls, html=html, url_params=url_params, body_params=body_params, injection_point=injection_point, cookie_params=cookie_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)       </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="injection_warrior" href="index.html">injection_warrior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="injection_warrior.warrior.Injector" href="#injection_warrior.warrior.Injector">Injector</a></code></h4>
<ul class="">
<li><code><a title="injection_warrior.warrior.Injector.inject_payload" href="#injection_warrior.warrior.Injector.inject_payload">inject_payload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>